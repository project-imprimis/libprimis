<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- The following icons and webmanifest were manually added. The rest is auto generated. -->
<!-- The favicons were resized for various screen sizes by https://favicon.io/. -->
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/>
<link rel="icon" type="image/png" sizes=16x16 href="favicon-16x16.png"/>
<link rel="icon" type="image/png" sizes=32x32 href="favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes=192x192 href="android-chrome-192x192.png"/>
<link rel="icon" type="image/png" sizes=512x512 href="android-chrome-512x512.png"/>
<link rel="apple-touch-icon" sizes=180x180 type="image/png" href="apple-touch-icon-180x180.png"/>
<link rel="manifest" href="site.webmanifest"/>
<!-- The previous icons and webmanifest were manually added. The rest is auto-genrated. -->
<title>Libprimis: vector&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-55x55.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Libprimis
   </div>
   <div id="projectbrief">Imprimis&#39; 3D destroyable world engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structvector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structvector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vector&lt; T &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A container template for storing variable lists of items.  
 <a href="structvector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tools_8h_source.html">tools.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00d237f22fd5eb1aa9a536993e82e54f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a00d237f22fd5eb1aa9a536993e82e54f">vector</a> ()</td></tr>
<tr class="memdesc:a00d237f22fd5eb1aa9a536993e82e54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector object.  <a href="structvector.html#a00d237f22fd5eb1aa9a536993e82e54f">More...</a><br /></td></tr>
<tr class="separator:a00d237f22fd5eb1aa9a536993e82e54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac636edc485bffa973b50b8bdfb1cc9cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ac636edc485bffa973b50b8bdfb1cc9cb">vector</a> (const <a class="el" href="structvector.html">vector</a> &amp;v)</td></tr>
<tr class="memdesc:ac636edc485bffa973b50b8bdfb1cc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the vector to another vector by reference.  <a href="structvector.html#ac636edc485bffa973b50b8bdfb1cc9cb">More...</a><br /></td></tr>
<tr class="separator:ac636edc485bffa973b50b8bdfb1cc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc236f547bb5debe890fa8ebaabe965"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a7bc236f547bb5debe890fa8ebaabe965">~vector</a> ()</td></tr>
<tr class="memdesc:a7bc236f547bb5debe890fa8ebaabe965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the vector object.  <a href="structvector.html#a7bc236f547bb5debe890fa8ebaabe965">More...</a><br /></td></tr>
<tr class="separator:a7bc236f547bb5debe890fa8ebaabe965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985cff80c58441215643ae45a95dd25c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a985cff80c58441215643ae45a95dd25c">operator=</a> (const <a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a985cff80c58441215643ae45a95dd25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector equal to the passed one.  <a href="structvector.html#a985cff80c58441215643ae45a95dd25c">More...</a><br /></td></tr>
<tr class="separator:a985cff80c58441215643ae45a95dd25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec1ffcada3738e7cdc86453f9b5c7d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a3bec1ffcada3738e7cdc86453f9b5c7d">add</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a3bec1ffcada3738e7cdc86453f9b5c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a reference to the back of the array, with assigned value.  <a href="structvector.html#a3bec1ffcada3738e7cdc86453f9b5c7d">More...</a><br /></td></tr>
<tr class="separator:a3bec1ffcada3738e7cdc86453f9b5c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad171b6218fb3c14a2d5d61d492f49a58"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ad171b6218fb3c14a2d5d61d492f49a58">add</a> ()</td></tr>
<tr class="memdesc:ad171b6218fb3c14a2d5d61d492f49a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a reference to the back of the array.  <a href="structvector.html#ad171b6218fb3c14a2d5d61d492f49a58">More...</a><br /></td></tr>
<tr class="separator:ad171b6218fb3c14a2d5d61d492f49a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46500dd47fc3f4ec51807719dbe0a793"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a46500dd47fc3f4ec51807719dbe0a793">dup</a> ()</td></tr>
<tr class="memdesc:a46500dd47fc3f4ec51807719dbe0a793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the last element in the array.  <a href="structvector.html#a46500dd47fc3f4ec51807719dbe0a793">More...</a><br /></td></tr>
<tr class="separator:a46500dd47fc3f4ec51807719dbe0a793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c9f84ea231d91dbe2507aa3aef82ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ad4c9f84ea231d91dbe2507aa3aef82ec">move</a> (<a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ad4c9f84ea231d91dbe2507aa3aef82ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this vector into the passed vector and vise versa.  <a href="structvector.html#ad4c9f84ea231d91dbe2507aa3aef82ec">More...</a><br /></td></tr>
<tr class="separator:ad4c9f84ea231d91dbe2507aa3aef82ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8b60b827cee171c65238526b27a623"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a9c8b60b827cee171c65238526b27a623">inrange</a> (size_t i) const</td></tr>
<tr class="memdesc:a9c8b60b827cee171c65238526b27a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the index passed is valid for this vector.  <a href="structvector.html#a9c8b60b827cee171c65238526b27a623">More...</a><br /></td></tr>
<tr class="separator:a9c8b60b827cee171c65238526b27a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc5cf788f4ff40e5c9c31f7ac10b5ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a4fc5cf788f4ff40e5c9c31f7ac10b5ce">inrange</a> (int i) const</td></tr>
<tr class="memdesc:a4fc5cf788f4ff40e5c9c31f7ac10b5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the index passed is valid for this vector.  <a href="structvector.html#a4fc5cf788f4ff40e5c9c31f7ac10b5ce">More...</a><br /></td></tr>
<tr class="separator:a4fc5cf788f4ff40e5c9c31f7ac10b5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b505ce7f65a2e6fc5ae20d783da9c2"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a86b505ce7f65a2e6fc5ae20d783da9c2">pop</a> ()</td></tr>
<tr class="memdesc:a86b505ce7f65a2e6fc5ae20d783da9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last value.  <a href="structvector.html#a86b505ce7f65a2e6fc5ae20d783da9c2">More...</a><br /></td></tr>
<tr class="separator:a86b505ce7f65a2e6fc5ae20d783da9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029771eec60cd92fe86827ee2557cb1d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a029771eec60cd92fe86827ee2557cb1d">last</a> ()</td></tr>
<tr class="memdesc:a029771eec60cd92fe86827ee2557cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last value in the array.  <a href="structvector.html#a029771eec60cd92fe86827ee2557cb1d">More...</a><br /></td></tr>
<tr class="separator:a029771eec60cd92fe86827ee2557cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbbd7fecd97f3c5e3262966ecd15a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a0cbbd7fecd97f3c5e3262966ecd15a66">drop</a> ()</td></tr>
<tr class="memdesc:a0cbbd7fecd97f3c5e3262966ecd15a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from the vector.  <a href="structvector.html#a0cbbd7fecd97f3c5e3262966ecd15a66">More...</a><br /></td></tr>
<tr class="separator:a0cbbd7fecd97f3c5e3262966ecd15a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af39ba556fbaeaa09cff474c6308076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a9af39ba556fbaeaa09cff474c6308076">empty</a> () const</td></tr>
<tr class="memdesc:a9af39ba556fbaeaa09cff474c6308076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether the vector has no elements.  <a href="structvector.html#a9af39ba556fbaeaa09cff474c6308076">More...</a><br /></td></tr>
<tr class="separator:a9af39ba556fbaeaa09cff474c6308076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5770d0ba12e51d3534986f1ae4655ea4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a5770d0ba12e51d3534986f1ae4655ea4">capacity</a> () const</td></tr>
<tr class="memdesc:a5770d0ba12e51d3534986f1ae4655ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of objects the vector can hold.  <a href="structvector.html#a5770d0ba12e51d3534986f1ae4655ea4">More...</a><br /></td></tr>
<tr class="separator:a5770d0ba12e51d3534986f1ae4655ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c907908675387470a149acfe8684811"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a6c907908675387470a149acfe8684811">length</a> () const</td></tr>
<tr class="memdesc:a6c907908675387470a149acfe8684811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the array.  <a href="structvector.html#a6c907908675387470a149acfe8684811">More...</a><br /></td></tr>
<tr class="separator:a6c907908675387470a149acfe8684811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5dc28a2e0035fc84a41f3588194853"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a8b5dc28a2e0035fc84a41f3588194853">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a8b5dc28a2e0035fc84a41f3588194853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at index i.  <a href="structvector.html#a8b5dc28a2e0035fc84a41f3588194853">More...</a><br /></td></tr>
<tr class="separator:a8b5dc28a2e0035fc84a41f3588194853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d35bc5e9b1f66d671c86432807f32f8"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a6d35bc5e9b1f66d671c86432807f32f8">operator[]</a> (int i) const</td></tr>
<tr class="memdesc:a6d35bc5e9b1f66d671c86432807f32f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at index i.  <a href="structvector.html#a6d35bc5e9b1f66d671c86432807f32f8">More...</a><br /></td></tr>
<tr class="separator:a6d35bc5e9b1f66d671c86432807f32f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1031db09c7d4027790ccb7b5e7d25472"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a1031db09c7d4027790ccb7b5e7d25472">disown</a> ()</td></tr>
<tr class="memdesc:a1031db09c7d4027790ccb7b5e7d25472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers ownership of array to return value.  <a href="structvector.html#a1031db09c7d4027790ccb7b5e7d25472">More...</a><br /></td></tr>
<tr class="separator:a1031db09c7d4027790ccb7b5e7d25472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8f5fea5bb485f72d4044a6b121e264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#aee8f5fea5bb485f72d4044a6b121e264">shrink</a> (int i)</td></tr>
<tr class="memdesc:aee8f5fea5bb485f72d4044a6b121e264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes elements until i are left.  <a href="structvector.html#aee8f5fea5bb485f72d4044a6b121e264">More...</a><br /></td></tr>
<tr class="separator:aee8f5fea5bb485f72d4044a6b121e264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a989ce0517774b2390d0641eccf835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a63a989ce0517774b2390d0641eccf835">setsize</a> (int i)</td></tr>
<tr class="memdesc:a63a989ce0517774b2390d0641eccf835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the used size of the array to i.  <a href="structvector.html#a63a989ce0517774b2390d0641eccf835">More...</a><br /></td></tr>
<tr class="separator:a63a989ce0517774b2390d0641eccf835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48aa137e8665f0e08ca13044312c828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#af48aa137e8665f0e08ca13044312c828">deletecontents</a> (int n=0)</td></tr>
<tr class="memdesc:af48aa137e8665f0e08ca13044312c828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes contents beyond the passed argument.  <a href="structvector.html#af48aa137e8665f0e08ca13044312c828">More...</a><br /></td></tr>
<tr class="separator:af48aa137e8665f0e08ca13044312c828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71e8013132ee3a5ec582d147579d2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ac71e8013132ee3a5ec582d147579d2f2">deletearrays</a> (int n=0)</td></tr>
<tr class="memdesc:ac71e8013132ee3a5ec582d147579d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes array contents beyond the passed argument.  <a href="structvector.html#ac71e8013132ee3a5ec582d147579d2f2">More...</a><br /></td></tr>
<tr class="separator:ac71e8013132ee3a5ec582d147579d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37662a6675e018cefdfc3543de9c731b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a37662a6675e018cefdfc3543de9c731b">getbuf</a> ()</td></tr>
<tr class="memdesc:a37662a6675e018cefdfc3543de9c731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the vector's internal array.  <a href="structvector.html#a37662a6675e018cefdfc3543de9c731b">More...</a><br /></td></tr>
<tr class="separator:a37662a6675e018cefdfc3543de9c731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a5e04878f77f49540e149c9f8d427f"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a15a5e04878f77f49540e149c9f8d427f">getbuf</a> () const</td></tr>
<tr class="memdesc:a15a5e04878f77f49540e149c9f8d427f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to const for the vector's internal array.  <a href="structvector.html#a15a5e04878f77f49540e149c9f8d427f">More...</a><br /></td></tr>
<tr class="separator:a15a5e04878f77f49540e149c9f8d427f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ed3bcb552484154fb959aa1f02a3a0"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:aa8ed3bcb552484154fb959aa1f02a3a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structvector.html#aa8ed3bcb552484154fb959aa1f02a3a0">sort</a> (F fun, int i=0, int n=-1)</td></tr>
<tr class="memdesc:aa8ed3bcb552484154fb959aa1f02a3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts using the passed function between passed indices.  <a href="structvector.html#aa8ed3bcb552484154fb959aa1f02a3a0">More...</a><br /></td></tr>
<tr class="separator:aa8ed3bcb552484154fb959aa1f02a3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7b573d71c078d65dc0e40b8409b700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a2f7b573d71c078d65dc0e40b8409b700">sort</a> ()</td></tr>
<tr class="memdesc:a2f7b573d71c078d65dc0e40b8409b700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the values of the array in ascending order.  <a href="structvector.html#a2f7b573d71c078d65dc0e40b8409b700">More...</a><br /></td></tr>
<tr class="separator:a2f7b573d71c078d65dc0e40b8409b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feade3a2946e44e2e13759fbe6bfd72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a0feade3a2946e44e2e13759fbe6bfd72">sortname</a> ()</td></tr>
<tr class="memdesc:a0feade3a2946e44e2e13759fbe6bfd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the values of the array in ascending order.  <a href="structvector.html#a0feade3a2946e44e2e13759fbe6bfd72">More...</a><br /></td></tr>
<tr class="separator:a0feade3a2946e44e2e13759fbe6bfd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500a5fefd99c45e122ffdedaf8cb55b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a500a5fefd99c45e122ffdedaf8cb55b6">growbuf</a> (int sz)</td></tr>
<tr class="memdesc:a500a5fefd99c45e122ffdedaf8cb55b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the array to the requested size.  <a href="structvector.html#a500a5fefd99c45e122ffdedaf8cb55b6">More...</a><br /></td></tr>
<tr class="separator:a500a5fefd99c45e122ffdedaf8cb55b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a83310c79698cbf1a0942ce80dfcd1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdatabuf.html">databuf</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a0a83310c79698cbf1a0942ce80dfcd1d">reserve</a> (int sz)</td></tr>
<tr class="memdesc:a0a83310c79698cbf1a0942ce80dfcd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the array by the amount requested.  <a href="structvector.html#a0a83310c79698cbf1a0942ce80dfcd1d">More...</a><br /></td></tr>
<tr class="separator:a0a83310c79698cbf1a0942ce80dfcd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4030f469794397798fff6928ea9b91c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ac4030f469794397798fff6928ea9b91c">advance</a> (int sz)</td></tr>
<tr class="memdesc:ac4030f469794397798fff6928ea9b91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the array's used length by the amount given.  <a href="structvector.html#ac4030f469794397798fff6928ea9b91c">More...</a><br /></td></tr>
<tr class="separator:ac4030f469794397798fff6928ea9b91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c232d5d8e81ee353c64ad51745fff54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a5c232d5d8e81ee353c64ad51745fff54">addbuf</a> (const <a class="el" href="structdatabuf.html">databuf</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a5c232d5d8e81ee353c64ad51745fff54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands the array given the size of a buffer.  <a href="structvector.html#a5c232d5d8e81ee353c64ad51745fff54">More...</a><br /></td></tr>
<tr class="separator:a5c232d5d8e81ee353c64ad51745fff54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b670eed6946439366e0188969104c2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a93b670eed6946439366e0188969104c2">pad</a> (int n)</td></tr>
<tr class="memdesc:a93b670eed6946439366e0188969104c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds n empty entries to the array.  <a href="structvector.html#a93b670eed6946439366e0188969104c2">More...</a><br /></td></tr>
<tr class="separator:a93b670eed6946439366e0188969104c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d44f0f942b1210dc91b8a3e8e88cc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ac3d44f0f942b1210dc91b8a3e8e88cc5">put</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ac3d44f0f942b1210dc91b8a3e8e88cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element to the vector.  <a href="structvector.html#ac3d44f0f942b1210dc91b8a3e8e88cc5">More...</a><br /></td></tr>
<tr class="separator:ac3d44f0f942b1210dc91b8a3e8e88cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231b000547521ee4c24bfc1c53a48d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a9231b000547521ee4c24bfc1c53a48d3">put</a> (const T *v, int n)</td></tr>
<tr class="memdesc:a9231b000547521ee4c24bfc1c53a48d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds n-1 empty entries after adding v.  <a href="structvector.html#a9231b000547521ee4c24bfc1c53a48d3">More...</a><br /></td></tr>
<tr class="separator:a9231b000547521ee4c24bfc1c53a48d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cb8f72325a5f52298ffac9abd8d102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a32cb8f72325a5f52298ffac9abd8d102">remove</a> (int i, int n)</td></tr>
<tr class="memdesc:a32cb8f72325a5f52298ffac9abd8d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes n elements starting at index i.  <a href="structvector.html#a32cb8f72325a5f52298ffac9abd8d102">More...</a><br /></td></tr>
<tr class="separator:a32cb8f72325a5f52298ffac9abd8d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515096bf4dcf9d9aeda81ece3c8b24b6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a515096bf4dcf9d9aeda81ece3c8b24b6">remove</a> (int i)</td></tr>
<tr class="memdesc:a515096bf4dcf9d9aeda81ece3c8b24b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the vector.  <a href="structvector.html#a515096bf4dcf9d9aeda81ece3c8b24b6">More...</a><br /></td></tr>
<tr class="separator:a515096bf4dcf9d9aeda81ece3c8b24b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a92723c52a0b1a02c2ad43e2a7672de"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a6a92723c52a0b1a02c2ad43e2a7672de">removeunordered</a> (int i)</td></tr>
<tr class="memdesc:a6a92723c52a0b1a02c2ad43e2a7672de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at index i, non-order preserving.  <a href="structvector.html#a6a92723c52a0b1a02c2ad43e2a7672de">More...</a><br /></td></tr>
<tr class="separator:a6a92723c52a0b1a02c2ad43e2a7672de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189bf4fa76f6304289a706b8b81767e"><td class="memTemplParams" colspan="2">template&lt;class U &gt; </td></tr>
<tr class="memitem:a6189bf4fa76f6304289a706b8b81767e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structvector.html#a6189bf4fa76f6304289a706b8b81767e">find</a> (const U &amp;o)</td></tr>
<tr class="memdesc:a6189bf4fa76f6304289a706b8b81767e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the argument inside this array.  <a href="structvector.html#a6189bf4fa76f6304289a706b8b81767e">More...</a><br /></td></tr>
<tr class="separator:a6189bf4fa76f6304289a706b8b81767e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6228008b964380b3e519a9949efda079"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a6228008b964380b3e519a9949efda079">addunique</a> (const T &amp;o)</td></tr>
<tr class="memdesc:a6228008b964380b3e519a9949efda079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an element iff it is not in the list.  <a href="structvector.html#a6228008b964380b3e519a9949efda079">More...</a><br /></td></tr>
<tr class="separator:a6228008b964380b3e519a9949efda079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10daba22a06b056f79048f614dccbd52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a10daba22a06b056f79048f614dccbd52">removeobj</a> (const T &amp;o)</td></tr>
<tr class="memdesc:a10daba22a06b056f79048f614dccbd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element by searching.  <a href="structvector.html#a10daba22a06b056f79048f614dccbd52">More...</a><br /></td></tr>
<tr class="separator:a10daba22a06b056f79048f614dccbd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1fe4bf71fda4f1f9fa65d7e810e6c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a5f1fe4bf71fda4f1f9fa65d7e810e6c4">replacewithlast</a> (const T &amp;o)</td></tr>
<tr class="memdesc:a5f1fe4bf71fda4f1f9fa65d7e810e6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element by searching, non order-preserving.  <a href="structvector.html#a5f1fe4bf71fda4f1f9fa65d7e810e6c4">More...</a><br /></td></tr>
<tr class="separator:a5f1fe4bf71fda4f1f9fa65d7e810e6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14839b92fd4f03eddd2026d72a3210e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ae14839b92fd4f03eddd2026d72a3210e">insert</a> (int i, const T &amp;e)</td></tr>
<tr class="memdesc:ae14839b92fd4f03eddd2026d72a3210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the specified index.  <a href="structvector.html#ae14839b92fd4f03eddd2026d72a3210e">More...</a><br /></td></tr>
<tr class="separator:ae14839b92fd4f03eddd2026d72a3210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085b2d77456aa7cb59ccdd5a0f98705a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a085b2d77456aa7cb59ccdd5a0f98705a">insert</a> (int i, const T *e, int n)</td></tr>
<tr class="memdesc:a085b2d77456aa7cb59ccdd5a0f98705a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts n elements at the specified index.  <a href="structvector.html#a085b2d77456aa7cb59ccdd5a0f98705a">More...</a><br /></td></tr>
<tr class="separator:a085b2d77456aa7cb59ccdd5a0f98705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d321ce952d2ac32c673623cb8cdb63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a34d321ce952d2ac32c673623cb8cdb63">reverse</a> ()</td></tr>
<tr class="memdesc:a34d321ce952d2ac32c673623cb8cdb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the vector.  <a href="structvector.html#a34d321ce952d2ac32c673623cb8cdb63">More...</a><br /></td></tr>
<tr class="separator:a34d321ce952d2ac32c673623cb8cdb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a20cf726867fca1a00b90aaa2f43893"><td class="memItemLeft" align="right" valign="top"><a id="a4a20cf726867fca1a00b90aaa2f43893" name="a4a20cf726867fca1a00b90aaa2f43893"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildheap</b> ()</td></tr>
<tr class="memdesc:a4a20cf726867fca1a00b90aaa2f43893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the vector in heap mode. <br /></td></tr>
<tr class="separator:a4a20cf726867fca1a00b90aaa2f43893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd16b607b5ed81b7e3a7ba5617712dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#aadd16b607b5ed81b7e3a7ba5617712dd">upheap</a> (int i)</td></tr>
<tr class="memdesc:aadd16b607b5ed81b7e3a7ba5617712dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares up the vector heap.  <a href="structvector.html#aadd16b607b5ed81b7e3a7ba5617712dd">More...</a><br /></td></tr>
<tr class="separator:aadd16b607b5ed81b7e3a7ba5617712dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c88e3f1982738d7547c81c0b4a2bdfc"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a2c88e3f1982738d7547c81c0b4a2bdfc">addheap</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2c88e3f1982738d7547c81c0b4a2bdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a number to the heap.  <a href="structvector.html#a2c88e3f1982738d7547c81c0b4a2bdfc">More...</a><br /></td></tr>
<tr class="separator:a2c88e3f1982738d7547c81c0b4a2bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd018336bccb491ad569e12c9ec6092b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#afd018336bccb491ad569e12c9ec6092b">downheap</a> (int i)</td></tr>
<tr class="memdesc:afd018336bccb491ad569e12c9ec6092b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks down the heap for valid children.  <a href="structvector.html#afd018336bccb491ad569e12c9ec6092b">More...</a><br /></td></tr>
<tr class="separator:afd018336bccb491ad569e12c9ec6092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7414b428036a6a109e2a40976e0eb1"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#aae7414b428036a6a109e2a40976e0eb1">removeheap</a> ()</td></tr>
<tr class="memdesc:aae7414b428036a6a109e2a40976e0eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first element from the heap.  <a href="structvector.html#aae7414b428036a6a109e2a40976e0eb1">More...</a><br /></td></tr>
<tr class="separator:aae7414b428036a6a109e2a40976e0eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb422be9160e47b6960ac83078e725bc"><td class="memTemplParams" colspan="2">template&lt;class K &gt; </td></tr>
<tr class="memitem:aeb422be9160e47b6960ac83078e725bc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structvector.html#aeb422be9160e47b6960ac83078e725bc">htfind</a> (const K &amp;key)</td></tr>
<tr class="memdesc:aeb422be9160e47b6960ac83078e725bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the key from a hashtable in the vector.  <a href="structvector.html#aeb422be9160e47b6960ac83078e725bc">More...</a><br /></td></tr>
<tr class="separator:aeb422be9160e47b6960ac83078e725bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf718ba43138d1e28f8e914fca4fd332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#adf718ba43138d1e28f8e914fca4fd332">unique</a> ()</td></tr>
<tr class="memdesc:adf718ba43138d1e28f8e914fca4fd332"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes every duplicate <b>stack allocated value</b> from the vector.  <a href="structvector.html#adf718ba43138d1e28f8e914fca4fd332">More...</a><br /></td></tr>
<tr class="separator:adf718ba43138d1e28f8e914fca4fd332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce497c56e52a9e9ef5593928692eae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a9ce497c56e52a9e9ef5593928692eae0">uniquedeletecontents</a> ()</td></tr>
<tr class="memdesc:a9ce497c56e52a9e9ef5593928692eae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes every duplicate <b>heap-allocated value</b> from the vector.  <a href="structvector.html#a9ce497c56e52a9e9ef5593928692eae0">More...</a><br /></td></tr>
<tr class="separator:a9ce497c56e52a9e9ef5593928692eae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec5680fd3731aaf7364b86e3e21f5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a55ec5680fd3731aaf7364b86e3e21f5a">uniquedeletearrays</a> ()</td></tr>
<tr class="memdesc:a55ec5680fd3731aaf7364b86e3e21f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes every duplicate <b>array value</b> from the vector.  <a href="structvector.html#a55ec5680fd3731aaf7364b86e3e21f5a">More...</a><br /></td></tr>
<tr class="separator:a55ec5680fd3731aaf7364b86e3e21f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5053033279ea5d16860228c1fb460b3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#ad5053033279ea5d16860228c1fb460b3">heapparent</a> (int i)</td></tr>
<tr class="memdesc:ad5053033279ea5d16860228c1fb460b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the binary heap parent of the index.  <a href="structvector.html#ad5053033279ea5d16860228c1fb460b3">More...</a><br /></td></tr>
<tr class="separator:ad5053033279ea5d16860228c1fb460b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960f7ccf713e2e29475b4534607573a5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a960f7ccf713e2e29475b4534607573a5">heapchild</a> (int i)</td></tr>
<tr class="memdesc:a960f7ccf713e2e29475b4534607573a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the first binary heap child of the index  <a href="structvector.html#a960f7ccf713e2e29475b4534607573a5">More...</a><br /></td></tr>
<tr class="separator:a960f7ccf713e2e29475b4534607573a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2bb835cb1456a5a1700906a49fe72483"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a2bb835cb1456a5a1700906a49fe72483">buf</a></td></tr>
<tr class="separator:a2bb835cb1456a5a1700906a49fe72483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf3e117a2c8618edc5dc0ef7c06e455"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a7bf3e117a2c8618edc5dc0ef7c06e455">alen</a></td></tr>
<tr class="separator:a7bf3e117a2c8618edc5dc0ef7c06e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add07f68356671ba0bf6537267fde2946"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#add07f68356671ba0bf6537267fde2946">ulen</a></td></tr>
<tr class="separator:add07f68356671ba0bf6537267fde2946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a698115fea16e441abf3ea84dd8376d3c"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector.html#a698115fea16e441abf3ea84dd8376d3c">MINSIZE</a> = 8</td></tr>
<tr class="separator:a698115fea16e441abf3ea84dd8376d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
struct vector&lt; T &gt;</div><p >A container template for storing variable lists of items. </p>
<p >This template implements a generic container class, consisting of a databuf object holding the data which changes size as the container has elements added to it. This container is similar in principle to std::vector&lt;&gt; but has a few notable differences in semantics.</p>
<p >The vector container does not support iterators, and therefore std library functions depending on them (such as <a class="el" href="structvector.html#a2f7b573d71c078d65dc0e40b8409b700" title="Sorts the values of the array in ascending order.">sort()</a>) will not work. Instead, the builtin functions for some such features are included in the class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the vector members </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00d237f22fd5eb1aa9a536993e82e54f" name="a00d237f22fd5eb1aa9a536993e82e54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d237f22fd5eb1aa9a536993e82e54f">&#9670;&nbsp;</a></span>vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvector.html">vector</a>&lt; T &gt;<a class="el" href="structvector.html">::vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector object. </p>
<p >Creates a new vector object of length 0 and an allocated length of 0; the buffer storing the data is not initialized. </p>

</div>
</div>
<a id="ac636edc485bffa973b50b8bdfb1cc9cb" name="ac636edc485bffa973b50b8bdfb1cc9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac636edc485bffa973b50b8bdfb1cc9cb">&#9670;&nbsp;</a></span>vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvector.html">vector</a>&lt; T &gt;<a class="el" href="structvector.html">::vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the vector to another vector by reference. </p>
<p >Points <code>this</code> vector to another vector passed by reference. The initialized parameters are replaced by the pointer assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector for this vector to point to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bc236f547bb5debe890fa8ebaabe965" name="a7bc236f547bb5debe890fa8ebaabe965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc236f547bb5debe890fa8ebaabe965">&#9670;&nbsp;</a></span>~vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvector.html">vector</a>&lt; T &gt;::~<a class="el" href="structvector.html">vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the vector object. </p>
<p >Deletes the vector and frees the space on the heap allocated to store the vector's data. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad171b6218fb3c14a2d5d61d492f49a58" name="ad171b6218fb3c14a2d5d61d492f49a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad171b6218fb3c14a2d5d61d492f49a58">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a reference to the back of the array. </p>
<p >Adds a reference to a new element located at the back of the vector. Dynamically allocates an object of type T on the heap (which will be constructed if necessary) and returns the reference to the newly created element.</p>
<p >This function has no equivalent in the std::vector&lt;&gt; methods, since iterators are used to represent addresses of values inside standard template library containers. The closest equivalent is manually allocating the pointer on the heap yourself, then pushing it back to a vector containing pointers or references using push_back().</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly created object </dd></dl>

</div>
</div>
<a id="a3bec1ffcada3738e7cdc86453f9b5c7d" name="a3bec1ffcada3738e7cdc86453f9b5c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec1ffcada3738e7cdc86453f9b5c7d">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a reference to the back of the array, with assigned value. </p>
<p >Adds a reference to a new element located at the back of the vector. Dynamically constructs a new object on the heap (using the value passed to construct it) and returns the reference to the newly created element.</p>
<p >This function's closest equivalents in std::vector&lt;&gt; are push_back() and emplace_back(). However, these functions do not return a reference to the newly created value.</p>
<p >The easiest way to replicate this behavior in std::vector is to create the new item at the back of the vector with emplace_back() followed by using back() to get a reference to the newly created vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the value to assign to the newly created value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the newly created object </dd></dl>

</div>
</div>
<a id="a5c232d5d8e81ee353c64ad51745fff54" name="a5c232d5d8e81ee353c64ad51745fff54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c232d5d8e81ee353c64ad51745fff54">&#9670;&nbsp;</a></span>addbuf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::addbuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdatabuf.html">databuf</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands the array given the size of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the buffer to get the length to expand by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c88e3f1982738d7547c81c0b4a2bdfc" name="a2c88e3f1982738d7547c81c0b4a2bdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c88e3f1982738d7547c81c0b4a2bdfc">&#9670;&nbsp;</a></span>addheap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::addheap </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a number to the heap. </p>
<p >Adds a new member at the end of the heap, and then compares it with its parents to place it in the correct part of the heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object to add to the heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6228008b964380b3e519a9949efda079" name="a6228008b964380b3e519a9949efda079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6228008b964380b3e519a9949efda079">&#9670;&nbsp;</a></span>addunique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::addunique </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element iff it is not in the list. </p>
<p >This method searches for an element with the same value, and adds a new element containing the value passed iff there is no identical element already present. Fails silently if the element already exists in the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The object to attempt to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4030f469794397798fff6928ea9b91c" name="ac4030f469794397798fff6928ea9b91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4030f469794397798fff6928ea9b91c">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::advance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands the array's used length by the amount given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>the amount to increase the size of the array by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5770d0ba12e51d3534986f1ae4655ea4" name="a5770d0ba12e51d3534986f1ae4655ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5770d0ba12e51d3534986f1ae4655ea4">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of objects the vector can hold. </p>
<p >Returns the total allocated size of the vector, in terms of the size of the object it is storing. This is equal to the maximum number of elements the vector can hold without having to expand its allocated space and copy its contents to a new array.</p>
<p >The std::vector&lt;&gt; equivalent of this method is also called <a class="el" href="structvector.html#a5770d0ba12e51d3534986f1ae4655ea4" title="Returns the number of objects the vector can hold.">capacity()</a>. </p><dl class="section return"><dt>Returns</dt><dd>the number of objects the vector can hold </dd></dl>

</div>
</div>
<a id="ac71e8013132ee3a5ec582d147579d2f2" name="ac71e8013132ee3a5ec582d147579d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71e8013132ee3a5ec582d147579d2f2">&#9670;&nbsp;</a></span>deletearrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::deletearrays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes array contents beyond the passed argument. </p>
<p >The elements of the vector with an index above n are deleted. This method is intended for vectors with array types; use deletcontents() instead for vectors of non-arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the last parameter to keep in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af48aa137e8665f0e08ca13044312c828" name="af48aa137e8665f0e08ca13044312c828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48aa137e8665f0e08ca13044312c828">&#9670;&nbsp;</a></span>deletecontents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::deletecontents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes contents beyond the passed argument. </p>
<p >The elements of the vector with an index above n are deleted. This method is intended for vectors with non-array types; use <a class="el" href="structvector.html#ac71e8013132ee3a5ec582d147579d2f2" title="Deletes array contents beyond the passed argument.">deletearrays()</a> instead for vectors of arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the last parameter to keep in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1031db09c7d4027790ccb7b5e7d25472" name="a1031db09c7d4027790ccb7b5e7d25472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1031db09c7d4027790ccb7b5e7d25472">&#9670;&nbsp;</a></span>disown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structvector.html">vector</a>&lt; T &gt;::disown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfers ownership of array to return value. </p>
<p >The vector's return array is de-assigned from the vector object and passed to the output.</p>
<p ><b>This function will cause a memory leak if the return value is not assigned to a variable. You must then call delete[] on this returned pointer to avoid the memory leak.</b> </p>

</div>
</div>
<a id="afd018336bccb491ad569e12c9ec6092b" name="afd018336bccb491ad569e12c9ec6092b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd018336bccb491ad569e12c9ec6092b">&#9670;&nbsp;</a></span>downheap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::downheap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks down the heap for valid children. </p>
<p >Moves elements around the heap beneath the given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index to evaluate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index representing the same data as the input index </dd></dl>

</div>
</div>
<a id="a0cbbd7fecd97f3c5e3262966ecd15a66" name="a0cbbd7fecd97f3c5e3262966ecd15a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbbd7fecd97f3c5e3262966ecd15a66">&#9670;&nbsp;</a></span>drop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::drop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last element from the vector. </p>
<p >Deletes the last element of the vector, de-allocating it from the heap.</p>
<p >The std::vector&lt;&gt; equivalent of this method is pop_back().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46500dd47fc3f4ec51807719dbe0a793" name="a46500dd47fc3f4ec51807719dbe0a793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46500dd47fc3f4ec51807719dbe0a793">&#9670;&nbsp;</a></span>dup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicates the last element in the array. </p>
<p >Copies and assigns to a new element at the end of the vector the value that the previous last member of the vector has. Expands the allocated length of the vector as necessary if there is no room left.</p>
<dl class="section return"><dt>Returns</dt><dd>the value of the entry which was duplicated. </dd></dl>

</div>
</div>
<a id="a9af39ba556fbaeaa09cff474c6308076" name="a9af39ba556fbaeaa09cff474c6308076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af39ba556fbaeaa09cff474c6308076">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structvector.html">vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries whether the vector has no elements. </p>
<p >Even if the vector has a large allocated memory size, this function returns true unless there are accessible elements.</p>
<p >The std::vector&lt;&gt; equivalent of this method is also called <a class="el" href="structvector.html#a9af39ba556fbaeaa09cff474c6308076" title="Queries whether the vector has no elements.">empty()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the vector has no elements </dd>
<dd>
false if the vector has elements </dd></dl>

</div>
</div>
<a id="a6189bf4fa76f6304289a706b8b81767e" name="a6189bf4fa76f6304289a706b8b81767e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6189bf4fa76f6304289a706b8b81767e">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the argument inside this array. </p>
<p >Returns the index of the vector where the argument is first found. If the object is not found, -1 is returned for the index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>the object to find in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the object found int the array </dd></dl>

</div>
</div>
<a id="a37662a6675e018cefdfc3543de9c731b" name="a37662a6675e018cefdfc3543de9c731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37662a6675e018cefdfc3543de9c731b">&#9670;&nbsp;</a></span>getbuf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structvector.html">vector</a>&lt; T &gt;::getbuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the vector's internal array. </p>
<p >Returns the address of the vector's internal array. If the vector's size changes, this pointer will become invalidated. The std::vector equivalent to this is data().</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vector's internal array. </dd></dl>

</div>
</div>
<a id="a15a5e04878f77f49540e149c9f8d427f" name="a15a5e04878f77f49540e149c9f8d427f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5e04878f77f49540e149c9f8d427f">&#9670;&nbsp;</a></span>getbuf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="structvector.html">vector</a>&lt; T &gt;::getbuf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to const for the vector's internal array. </p>
<p >Returns the address of the vector's internal array. If the vector's size changes, this pointer will become invalidated. This vector points to const, so it cannot change the values it sees.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to const for the vector's internal array. </dd></dl>

</div>
</div>
<a id="a500a5fefd99c45e122ffdedaf8cb55b6" name="a500a5fefd99c45e122ffdedaf8cb55b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500a5fefd99c45e122ffdedaf8cb55b6">&#9670;&nbsp;</a></span>growbuf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::growbuf </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands the array to the requested size. </p>
<p >If successful, the pointer to the new data array will be changed, invalidating any existing pointers. Fails silently if the requested size is smaller than the current allocated size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>the new requested size of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a960f7ccf713e2e29475b4534607573a5" name="a960f7ccf713e2e29475b4534607573a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960f7ccf713e2e29475b4534607573a5">&#9670;&nbsp;</a></span>heapchild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::heapchild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the first binary heap child of the index </p>
<p >For this result to make sense, the vector must be put in heap mode using <a class="el" href="structvector.html#a4a20cf726867fca1a00b90aaa2f43893" title="Puts the vector in heap mode.">buildheap()</a>.</p>
<p >The second heap child is located at the return value plus one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5053033279ea5d16860228c1fb460b3" name="ad5053033279ea5d16860228c1fb460b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5053033279ea5d16860228c1fb460b3">&#9670;&nbsp;</a></span>heapparent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::heapparent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the binary heap parent of the index. </p>
<p >For this result to make sense, the vector must be put in heap mode using <a class="el" href="structvector.html#a4a20cf726867fca1a00b90aaa2f43893" title="Puts the vector in heap mode.">buildheap()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb422be9160e47b6960ac83078e725bc" name="aeb422be9160e47b6960ac83078e725bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb422be9160e47b6960ac83078e725bc">&#9670;&nbsp;</a></span>htfind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::htfind </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds the key from a hashtable in the vector. </p>
<p >the implementation takes advantage of the numerous overloads of the htcmp() function. Note that this means the generic parameter can be one of the following:</p><ul>
<li>const char *</li>
<li>const stringslice</li>
<li>int</li>
<li>GLuint</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the index of the element if it exists; -1 otherwise </dd></dl>

</div>
</div>
<a id="a4fc5cf788f4ff40e5c9c31f7ac10b5ce" name="a4fc5cf788f4ff40e5c9c31f7ac10b5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc5cf788f4ff40e5c9c31f7ac10b5ce">&#9670;&nbsp;</a></span>inrange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structvector.html">vector</a>&lt; T &gt;::inrange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the index passed is valid for this vector. </p>
<p >Compares the size of the vector to the integer given.</p>
<p >The std::vector equivalent is to compare the desired value to the size() of the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to validate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index is in range </dd>
<dd>
false if the index is out of range </dd></dl>

</div>
</div>
<a id="a9c8b60b827cee171c65238526b27a623" name="a9c8b60b827cee171c65238526b27a623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8b60b827cee171c65238526b27a623">&#9670;&nbsp;</a></span>inrange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structvector.html">vector</a>&lt; T &gt;::inrange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the index passed is valid for this vector. </p>
<p >Compares the size of the vector to the size_t given</p>
<p >The std::vector equivalent is to compare the desired value to the size() of the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to validate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the index is in range </dd>
<dd>
false if the index is out of range </dd></dl>

</div>
</div>
<a id="ae14839b92fd4f03eddd2026d72a3210e" name="ae14839b92fd4f03eddd2026d72a3210e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14839b92fd4f03eddd2026d72a3210e">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element at the specified index. </p>
<p >Adds an element to the vector at the specified location. The std::vector&lt;&gt; equivalent is also called <a class="el" href="structvector.html#ae14839b92fd4f03eddd2026d72a3210e" title="Inserts an element at the specified index.">insert()</a> and has essentially the same semantics, except that std::vector&lt;&gt; returns an iterator and this function returns a copy of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index to insert at </td></tr>
    <tr><td class="paramname">e</td><td>element to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value that was inserted into the array </dd></dl>

</div>
</div>
<a id="a085b2d77456aa7cb59ccdd5a0f98705a" name="a085b2d77456aa7cb59ccdd5a0f98705a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085b2d77456aa7cb59ccdd5a0f98705a">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structvector.html">vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts n elements at the specified index. </p>
<p >Adds n elements to the vector at the specified index. Equivalent to calling insert(int, const T) multiple times with i, i+1, i+2... i+n, except slightly more efficient. The same value e is assigned to all n entries created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>index to insert at </td></tr>
    <tr><td class="paramname">e</td><td>element to insert </td></tr>
    <tr><td class="paramname">n</td><td>number of elements to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a029771eec60cd92fe86827ee2557cb1d" name="a029771eec60cd92fe86827ee2557cb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029771eec60cd92fe86827ee2557cb1d">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last value in the array. </p>
<p >The std::vector&lt;&gt; equivalent of this method is back().</p>
<dl class="section return"><dt>Returns</dt><dd>the last element in the array </dd></dl>

</div>
</div>
<a id="a6c907908675387470a149acfe8684811" name="a6c907908675387470a149acfe8684811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c907908675387470a149acfe8684811">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the array. </p>
<p >Returns the number of entries in the array. The std::vector&lt;&gt; equivalent of this method is called size()</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the array </dd></dl>

</div>
</div>
<a id="ad4c9f84ea231d91dbe2507aa3aef82ec" name="ad4c9f84ea231d91dbe2507aa3aef82ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c9f84ea231d91dbe2507aa3aef82ec">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this vector into the passed vector and vise versa. </p>
<p >Moves the values of *this into the vector pointed to by v, and moves the values inside v into *this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a985cff80c58441215643ae45a95dd25c" name="a985cff80c58441215643ae45a95dd25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985cff80c58441215643ae45a95dd25c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector equal to the passed one. </p>
<p >Returns this vector, after copying the values from the passed vector to it. The allocated length of the two vectors are not necessarily equal after copying; however the assigned values will be equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector to copy to this vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of type T with the values of v </dd></dl>

</div>
</div>
<a id="a8b5dc28a2e0035fc84a41f3588194853" name="a8b5dc28a2e0035fc84a41f3588194853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5dc28a2e0035fc84a41f3588194853">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at index i. </p>
<p >Gets the ith element in the vector. Does not protect against the boundaries of the vector, either below or above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to get the element for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the element at index i </dd></dl>

</div>
</div>
<a id="a6d35bc5e9b1f66d671c86432807f32f8" name="a6d35bc5e9b1f66d671c86432807f32f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d35bc5e9b1f66d671c86432807f32f8">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the element at index i. </p>
<p >Gets the ith element in the vector. Does not protect against the boundaries of the vector, either below or above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to get the element for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the element at index i </dd></dl>

</div>
</div>
<a id="a93b670eed6946439366e0188969104c2" name="a93b670eed6946439366e0188969104c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b670eed6946439366e0188969104c2">&#9670;&nbsp;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structvector.html">vector</a>&lt; T &gt;::pad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds n empty entries to the array. </p>
<p >If this operation extends the vector beyond its original allocated length, old array pointers will become invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of empty entries to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86b505ce7f65a2e6fc5ae20d783da9c2" name="a86b505ce7f65a2e6fc5ae20d783da9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b505ce7f65a2e6fc5ae20d783da9c2">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes and returns the last value. </p>
<p >Shortens the end of the array by one and returns the value previously stored at that location.</p>
<dl class="section return"><dt>Returns</dt><dd>the element that was popped off the end </dd></dl>

</div>
</div>
<a id="ac3d44f0f942b1210dc91b8a3e8e88cc5" name="ac3d44f0f942b1210dc91b8a3e8e88cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d44f0f942b1210dc91b8a3e8e88cc5">&#9670;&nbsp;</a></span>put() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an element to the vector. </p>
<p >This function is a wrapper around <a class="el" href="structvector.html#ad171b6218fb3c14a2d5d61d492f49a58" title="Adds a reference to the back of the array.">add()</a> and has no other behavior. The std::vector&lt;&gt; equivalent is either push_back() or emplace_back().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the element to add to the vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9231b000547521ee4c24bfc1c53a48d3" name="a9231b000547521ee4c24bfc1c53a48d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9231b000547521ee4c24bfc1c53a48d3">&#9670;&nbsp;</a></span>put() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::put </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds n-1 empty entries after adding v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the value to assign to the </td></tr>
    <tr><td class="paramname">n</td><td>the number of total entries to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a515096bf4dcf9d9aeda81ece3c8b24b6" name="a515096bf4dcf9d9aeda81ece3c8b24b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515096bf4dcf9d9aeda81ece3c8b24b6">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structvector.html">vector</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from the vector. </p>
<p >Removes the ith element of the vector. If i is greater than the size of the vector, the array is accessed out-of-bounds. The elements beyond the index selected are all moved forward one space, and the element removed is returned by value.</p>
<p >The equivalent std::vector&lt;&gt; expression is to get the element's value with operator[] or at() and then to remove the element with erase().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of the element to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the element removed </dd></dl>

</div>
</div>
<a id="a32cb8f72325a5f52298ffac9abd8d102" name="a32cb8f72325a5f52298ffac9abd8d102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cb8f72325a5f52298ffac9abd8d102">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes n elements starting at index i. </p>
<p >Removes elements (one-indexed) starting with the element after i and continuing for n entries. Shifts entries beyond those removed by copying to lower array indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index after which elements are removed </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae7414b428036a6a109e2a40976e0eb1" name="aae7414b428036a6a109e2a40976e0eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7414b428036a6a109e2a40976e0eb1">&#9670;&nbsp;</a></span>removeheap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structvector.html">vector</a>&lt; T &gt;::removeheap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the first element from the heap. </p>
<p >Removes the element at the top of the heap. Recalculates the heap structure after removing the top element.</p>
<dl class="section return"><dt>Returns</dt><dd>the value that was removed </dd></dl>

</div>
</div>
<a id="a10daba22a06b056f79048f614dccbd52" name="a10daba22a06b056f79048f614dccbd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10daba22a06b056f79048f614dccbd52">&#9670;&nbsp;</a></span>removeobj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::removeobj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes element by searching. </p>
<p >Attempts to remove an element that compares equal to the argument passed. Only removes the first element found, if multiple identical entries to the argument are found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The object to search for to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a92723c52a0b1a02c2ad43e2a7672de" name="a6a92723c52a0b1a02c2ad43e2a7672de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a92723c52a0b1a02c2ad43e2a7672de">&#9670;&nbsp;</a></span>removeunordered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structvector.html">vector</a>&lt; T &gt;::removeunordered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at index i, non-order preserving. </p>
<p >Removes the ith element of the vector, copying the last element into its location. This changes the resulting order of the vector, while avoiding a more costly shift of vector entries from i upwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of the value to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the element removed </dd></dl>

</div>
</div>
<a id="a5f1fe4bf71fda4f1f9fa65d7e810e6c4" name="a5f1fe4bf71fda4f1f9fa65d7e810e6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1fe4bf71fda4f1f9fa65d7e810e6c4">&#9670;&nbsp;</a></span>replacewithlast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::replacewithlast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes element by searching, non order-preserving. </p>
<p >Attempts to remove an element that compares equal to the argument passed, replacing it with the last element. If multiple identical entries to the argument are found, only the first element is removed.</p>
<p >This function acts similarly to <a class="el" href="structvector.html#a10daba22a06b056f79048f614dccbd52" title="Removes element by searching.">removeobj()</a> but does not preserve the order of the resulting vector; it is faster however by not having to shift elements i and upward to preserve the order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>THe object to search for to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a83310c79698cbf1a0942ce80dfcd1d" name="a0a83310c79698cbf1a0942ce80dfcd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a83310c79698cbf1a0942ce80dfcd1d">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdatabuf.html">databuf</a>&lt; T &gt; <a class="el" href="structvector.html">vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expands the array by the amount requested. </p>
<p >Expands the data array by the amount requested. Silently fails to expand the array if it is already long enough. If this operation succeeds, the pointers to the old array will become invalidated.</p>
<dl class="section return"><dt>Returns</dt><dd>the buffer starting at the old used length for sz entries </dd></dl>

</div>
</div>
<a id="a34d321ce952d2ac32c673623cb8cdb63" name="a34d321ce952d2ac32c673623cb8cdb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d321ce952d2ac32c673623cb8cdb63">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the vector. </p>
<p >Flips the first n/2 (rounded down) elements with the back n/2 elements, changing the vector's array so that it is in reverse. </p>

</div>
</div>
<a id="a63a989ce0517774b2390d0641eccf835" name="a63a989ce0517774b2390d0641eccf835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a989ce0517774b2390d0641eccf835">&#9670;&nbsp;</a></span>setsize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::setsize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the used size of the array to i. </p>
<p >Sets the used size of the array to i, even if it is negative or larger than the allocated length. </p>

</div>
</div>
<a id="aee8f5fea5bb485f72d4044a6b121e264" name="aee8f5fea5bb485f72d4044a6b121e264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8f5fea5bb485f72d4044a6b121e264">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::shrink </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes elements until i are left. </p>
<p >The vector's values beyond i are all dropped, leaving a vector of size i as the remainder. Has no effect if the size to shrink to is equal to or larger than the vector was originally.</p>
<p >The std::vector equivalent to this function is to call <code>resize()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the last index in the array to keep </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f7b573d71c078d65dc0e40b8409b700" name="a2f7b573d71c078d65dc0e40b8409b700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f7b573d71c078d65dc0e40b8409b700">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the values of the array in ascending order. </p>
<p >Runs the quicksort algorithm to sort the values in the vector in ascending order. The std::vector&lt;&gt; equivalent of this operation is std::sort(vector.begin(), vector.end()).</p>
<p >This operation has a time complexity of n*log(n) on average and n^2 in the worst-case scenario. </p>

</div>
</div>
<a id="aa8ed3bcb552484154fb959aa1f02a3a0" name="aa8ed3bcb552484154fb959aa1f02a3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ed3bcb552484154fb959aa1f02a3a0">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts using the passed function between passed indices. </p>
<p >Calls quicksort on <code>this</code> array, using the comparison function passed as its first argument. If n = -1, the last element to be sorted is the last element of the array. Other wise, the array is sorted between <code>i</code> and <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fun</td><td>the function to sort elements with </td></tr>
    <tr><td class="paramname">i</td><td>the first element to sort from </td></tr>
    <tr><td class="paramname">n</td><td>the last element to sort until </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0feade3a2946e44e2e13759fbe6bfd72" name="a0feade3a2946e44e2e13759fbe6bfd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0feade3a2946e44e2e13759fbe6bfd72">&#9670;&nbsp;</a></span>sortname()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::sortname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the values of the array in ascending order. </p>
<p >Runs the quicksort algorithm to sort the values in the vector in ascending order. This function calls <a class="el" href="structsortnameless.html">sortnameless()</a> which calls <a class="el" href="structsortless.html">sortless()</a>, so the behavior is the same as <a class="el" href="structvector.html#a2f7b573d71c078d65dc0e40b8409b700" title="Sorts the values of the array in ascending order.">sort()</a> The std::vector&lt;&gt; equivalent of this operation is std::sort(vector.begin(), vector.end()).</p>
<p >This operation has a time complexity of n*log(n) on average and n^2 in the worst-case scenario. </p>

</div>
</div>
<a id="adf718ba43138d1e28f8e914fca4fd332" name="adf718ba43138d1e28f8e914fca4fd332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf718ba43138d1e28f8e914fca4fd332">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes every duplicate <b>stack allocated value</b> from the vector. </p>
<p >Contents must be initally sorted. Duplicated items get deleted via a call to <a class="el" href="structvector.html#a63a989ce0517774b2390d0641eccf835" title="Sets the used size of the array to i.">setsize()</a>.</p>
<p ><b>It may leak memory if used with heap allocated and array items.</b> <b>see <a class="el" href="structvector.html#a9ce497c56e52a9e9ef5593928692eae0" title="removes every duplicate heap-allocated value from the vector.">uniquedeletecontents()</a> and <a class="el" href="structvector.html#a55ec5680fd3731aaf7364b86e3e21f5a" title="removes every duplicate array value from the vector.">uniquedeletearrays()</a> for that case</b> </p>

</div>
</div>
<a id="a55ec5680fd3731aaf7364b86e3e21f5a" name="a55ec5680fd3731aaf7364b86e3e21f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ec5680fd3731aaf7364b86e3e21f5a">&#9670;&nbsp;</a></span>uniquedeletearrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::uniquedeletearrays </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes every duplicate <b>array value</b> from the vector. </p>
<p >Duplicated items get deleted via <a class="el" href="structvector.html#ac71e8013132ee3a5ec582d147579d2f2" title="Deletes array contents beyond the passed argument.">deletearrays()</a>. for the equivalent function for stack values see <a class="el" href="structvector.html#adf718ba43138d1e28f8e914fca4fd332" title="removes every duplicate stack allocated value from the vector.">unique()</a>. for the equivalent function for heap-allocated values see <a class="el" href="structvector.html#a9ce497c56e52a9e9ef5593928692eae0" title="removes every duplicate heap-allocated value from the vector.">uniquedeletecontents()</a>. </p>

</div>
</div>
<a id="a9ce497c56e52a9e9ef5593928692eae0" name="a9ce497c56e52a9e9ef5593928692eae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce497c56e52a9e9ef5593928692eae0">&#9670;&nbsp;</a></span>uniquedeletecontents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structvector.html">vector</a>&lt; T &gt;::uniquedeletecontents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes every duplicate <b>heap-allocated value</b> from the vector. </p>
<p >Duplicated items get deleted via <a class="el" href="structvector.html#af48aa137e8665f0e08ca13044312c828" title="Deletes contents beyond the passed argument.">deletecontents()</a>. for the equivalent function for stack values see <a class="el" href="structvector.html#adf718ba43138d1e28f8e914fca4fd332" title="removes every duplicate stack allocated value from the vector.">unique()</a>. for the equivalent function for array values see <a class="el" href="structvector.html#a55ec5680fd3731aaf7364b86e3e21f5a" title="removes every duplicate array value from the vector.">uniquedeletearrays()</a>. </p>

</div>
</div>
<a id="aadd16b607b5ed81b7e3a7ba5617712dd" name="aadd16b607b5ed81b7e3a7ba5617712dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd16b607b5ed81b7e3a7ba5617712dd">&#9670;&nbsp;</a></span>upheap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::upheap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares up the vector heap. </p>
<p >Used when adding a member to the heap. Ensures that upstream members all satisfy the binary heap condition and moves members accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index to evaluate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index representing the same data as the input index </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7bf3e117a2c8618edc5dc0ef7c06e455" name="a7bf3e117a2c8618edc5dc0ef7c06e455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf3e117a2c8618edc5dc0ef7c06e455">&#9670;&nbsp;</a></span>alen</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::alen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The allocated length of the vector, including unused space in the buffer. </p>

</div>
</div>
<a id="a2bb835cb1456a5a1700906a49fe72483" name="a2bb835cb1456a5a1700906a49fe72483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb835cb1456a5a1700906a49fe72483">&#9670;&nbsp;</a></span>buf</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structvector.html">vector</a>&lt; T &gt;::buf</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The array of data values making up the vector's data. </p>

</div>
</div>
<a id="a698115fea16e441abf3ea84dd8376d3c" name="a698115fea16e441abf3ea84dd8376d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698115fea16e441abf3ea84dd8376d3c">&#9670;&nbsp;</a></span>MINSIZE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::MINSIZE = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The minimum number of elements a vector can be created with. </p>

</div>
</div>
<a id="add07f68356671ba0bf6537267fde2946" name="add07f68356671ba0bf6537267fde2946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add07f68356671ba0bf6537267fde2946">&#9670;&nbsp;</a></span>ulen</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structvector.html">vector</a>&lt; T &gt;::ulen</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The used length of the vector, only counting the part of the buffer which has a vector index </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/github/workspace/src/libprimis-headers/<a class="el" href="tools_8h_source.html">tools.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structvector.html">vector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
