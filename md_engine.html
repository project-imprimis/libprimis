<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- The following icons and webmanifest were manually added. The rest is auto generated. -->
<!-- The favicons were resized for various screen sizes by https://favicon.io/. -->
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon"/>
<link rel="icon" type="image/png" sizes=16x16 href="favicon-16x16.png"/>
<link rel="icon" type="image/png" sizes=32x32 href="favicon-32x32.png"/>
<link rel="icon" type="image/png" sizes=192x192 href="android-chrome-192x192.png"/>
<link rel="icon" type="image/png" sizes=512x512 href="android-chrome-512x512.png"/>
<link rel="apple-touch-icon" sizes=180x180 type="image/png" href="apple-touch-icon-180x180.png"/>
<link rel="manifest" href="site.webmanifest"/>
<!-- The previous icons and webmanifest were manually added. The rest is auto-genrated. -->
<title>Libprimis: The Libprimis Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo-55x55.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Libprimis
   </div>
   <div id="projectbrief">Imprimis&#39; 3D destroyable world engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_engine.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">The Libprimis Engine </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><b>This is a work in progress and subject to modification and additions.</b></p>
<p >Written and © Alex "no-lex" Foster, 2020-2021; released under the WTFPL v2.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Preface</h1>
<p >This text is an expository one, describing the <em>what</em> and some of the <em>why</em> things are implemented as they are in the engine. This document does not attempt to explain how the game is implemented.</p>
<p >Note that this text is written by someone who did not write the actual code for the engine: as a result, it is possible that some of this document is misconstrued from the original intent of the code writers. As those people are not particularly available, this text represents the best guess of the author.</p>
<p >This text is an attempt to describe the engine in such a way that previous Cube-based engines were not. For nearly two decades, the Cube series of engines, including the original Cube as well as Cube 2 and Tesseract, have been among the most technologically advanced first-person shooter engines available to the open source community, but their adoption has been limited by the relative inability to understand the source code due to a lack of comprehensive documentation and often opaque coding styles. This text is an attempt to lay down the architecture of the engine, and provide the skeleton required to understand specific code that is written in the engine.</p>
<p >To fully understand this text, it is expected that readers understand the basics of functional and object-oriented programming paradigms, as well as have a basic knowledge of linear and vector algebra; these mathematical concepts are the core of how 3D engines like Libprimis' are designed. A few rendering techniques, such as global illumination, additionally use more complex mathematics borrowed from linear analysis, including multipole expansions and Fourier series.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
1. Standards</h1>
<p >To be a functioning project, Libprimis has some standards which make it straightforward to communicate effectively. While some particular standards may be clumsy for particular uses, it is important that the project be consistent, not only for clarity of code but also for documentation and ease of extension.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
1.1 Coding Standards</h2>
<h3><a class="anchor" id="autotoc_md11"></a>
1.1.1 This File</h3>
<p >This file is written to be interpreted by GitHub Flavored Markdown (GFM) and must satisfy the standards laid out therein.</p>
<p >Text should institute a line break after 80 characters.</p>
<p >Chapters use <code>#</code>; sections use <code>##</code>; subsections use <code>###</code>. Minor topics within subsections can use <code>####</code>.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
1.1.2 C/C++ Standards</h3>
<p >Four spaces per indentation, spaces only. Opening brackets get their own new line; this is called "Allman style".</p>
<h4><a class="anchor" id="autotoc_md13"></a>
Symbol Names</h4>
<p >Macros are always fully capitalized and seperated with underscores:</p>
<p ><code>#define MACRO_NAME</code> <code>#define MACRO_FUNCTION(a, b)</code></p>
<p >Do not use macros unless there is no other salient way to approach the problem. If a macro is the best way to solve a particular problem, it should be explained with surrounding comments.</p>
<p >Variables are always lowercase:</p>
<p ><code>int varname</code></p>
<p >Functions are always lowercase:</p>
<p ><code>void functionname()</code></p>
<p >Enum elements are in PascalCase:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span></div>
<div class="line">{</div>
<div class="line">    Name_ElementOne   = 1,</div>
<div class="line">    Name_ElementTwo   = 2,</div>
<div class="line">    Name_ElementThree = 3,</div>
<div class="line">};</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md14"></a>
Enums</h4>
<p >Enums also are always expanded with a single element per line. For aesthetics, it is best to place all the equals in the same location (as above). Libprimis uses no named enums besides those inhereted from ENet.</p>
<h4><a class="anchor" id="autotoc_md15"></a>
Objects</h4>
<p >Objects of POD type (Plain Old Data) should be assigned the keyword <code>struct</code>, and objects of a complex type should be given the keyword <code>class</code>. Where applicable, objects should be separated into <code>public</code> and <code>private</code>, with <code>public</code> members being declared first.</p>
<h4><a class="anchor" id="autotoc_md16"></a>
`for` loops</h4>
<p >The accepted conventional variables for loops are the single letter <code>i</code>,<code>j</code>,<code>k</code>, <code>l</code> temp vars. Use later loop variables only if the earlier ones are already present (don't use a loop over <code>j</code> unless it's inside a loop over <code>i</code>).</p>
<p >The convention for incrementing loops (counting upwards) is as follows:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; N; ++i)</div>
</div><!-- fragment --><p> Change the value passed to <code>N</code> rather than using a less than or equals sign <code>&lt;=</code> so as to keep all for() statements clear as to their termination point immediately.</p>
<p >For decrementing loops (counting downwards):</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = N; --i &gt;= 0;)</div>
</div><!-- fragment --><p >For loops over the length of a vector, use</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; N.length(); j++) <span class="comment">//forward iteration</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> v = m; --v &gt;= 0;) <span class="comment">//reverse iteration</span></div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md17"></a>
Indentation and Bracing</h4>
<p >The codebase uses the Allman style; that is, statements are enclosed in brackets on newlines. Case statements are indented one tab past their opening switch statement.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>MyNamespace</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> var1, var2, var3;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> var4 = foo(myfunction()),</div>
<div class="line">        var5 = bar(foo()),</div>
<div class="line">        var6 = foo(foo() || foo(bar) || foo(baz));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum</span></div>
<div class="line">    {</div>
<div class="line">        Name_ElementOne   = 1,</div>
<div class="line">        Name_ElementTwo   = 2,</div>
<div class="line">        Name_ElementThree = 3,</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>baz</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> var1;</div>
<div class="line">        <span class="keywordtype">char</span> var2;</div>
<div class="line">        <span class="keyword">union</span></div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">char</span> var3[8];</div>
<div class="line">            <span class="keywordtype">int</span> var4;</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(foo())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">int</span> a;</div>
<div class="line">        <span class="keywordtype">int</span> b;</div>
<div class="line">        doStuff;</div>
<div class="line">        doMoreStuff;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        doStuff;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        doStuff;</div>
<div class="line">    } <span class="keywordflow">while</span>(bar)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span>(foo)</div>
<div class="line">    {</div>
<div class="line">        doStuff;</div>
<div class="line">    }</div>
<div class="line"><span class="comment">//=====================================================================MACRONAME</span></div>
<div class="line"><span class="preprocessor">#define MACRO_NAME(a,b) stuff(a,b)</span></div>
<div class="line">    <span class="keywordtype">int</span> myfunction(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b = 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i; i &lt; N; ++N)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span>(bar)</div>
<div class="line">            {</div>
<div class="line">                <span class="keywordflow">switch</span>(n)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">case</span> 1:</div>
<div class="line">                    {</div>
<div class="line">                        doStuff;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">case</span> 2:</div>
<div class="line">                    {</div>
<div class="line">                        doStuff;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">case</span> 3:</div>
<div class="line">                    <span class="keywordflow">case</span> 4:</div>
<div class="line">                    <span class="keywordflow">case</span> N:</div>
<div class="line">                    {</div>
<div class="line">                        doStuff;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        MACRO_NAME(a,b)</div>
<div class="line">        <span class="keywordflow">return</span> a;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#undef MACRONAME</span></div>
<div class="line"><span class="comment">//==============================================================================</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Foo&gt;</div>
<div class="line"><span class="keyword">inline</span> Foo func(Foo var)</div>
<div class="line">{</div>
<div class="line">    bar(var);</div>
<div class="line">    <span class="keywordflow">return</span>(var);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Note that template declarations should have the template declaration on its own line.</p>
<p >Control flow statements (if/while/do-while etc.) should get their own line; don't do stuff like</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(foo) <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i; i &lt; N; ++i) { doStuff; doMoreStuff }</div>
</div><!-- fragment --><p >In addition, always delimit statements after control expressions with curly braces, even if there is only one expression:</p>
<div class="fragment"><div class="line"><span class="comment">//do this</span></div>
<div class="line"><span class="keywordflow">if</span>(foo)</div>
<div class="line">{</div>
<div class="line">    doStuff;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//not this</span></div>
<div class="line"><span class="keywordflow">if</span>(foo)</div>
<div class="line">    doStuff;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18"></a>
Spacing</h4>
<p >Ternaries and boolean operators should be spaced out between each element:</p>
<div class="fragment"><div class="line">foo ? bar : baz</div>
<div class="line">foo &gt;= bar</div>
<div class="line">foo || bar</div>
</div><!-- fragment --><p >Arithmetic can be done without spaces, however:</p>
<div class="fragment"><div class="line">foo+1</div>
<div class="line">3*bar</div>
</div><!-- fragment --><p >Operators should remain packed against their parentheses:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span>(foo)</div>
<div class="line">{</div>
<div class="line">    stuff</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(bar)</div>
<div class="line">{</div>
<div class="line">    stuff</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
1.2 Default Paths &amp; Libraries</h2>
<h3><a class="anchor" id="autotoc_md20"></a>
1.2.1 Paths</h3>
<p >Linux: <code>~/.imprimis</code> is the "home" directory by default. Windows: <code>~/My Games/Imprimis</code> is the "home" directory by default.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
1.2.2 Libraries</h3>
<p >This game requires <code>libsdl2, libsdl2-mixer, libsdl2-image</code>, and <code>libsdl2-ttf</code> to run, including the <code>-dev</code> versions for those package managers which elect to seperate them (such as Ubuntu) if compiling the game. As the main way of getting the game is via Git, the best way to retrieve the assets for the game is by the command line utility <code>git</code>.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
1.3 Conventions and Units</h2>
<p >Libprimis uses some standard units which allow for users to contextualize and orient themselves in the worlds it creates.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
1.3.1 Distances</h3>
<p >Distance is always in the unit of cube units ("cubits"), which is the size of a gridpower 0 cube, when not specified. This distance is equal to an eighth of a meter, 12.5 centimeters, or approximately five inches (to within a couple %).</p>
<h3><a class="anchor" id="autotoc_md24"></a>
1.3.2 Coordinates</h3>
<p >Octree nodes, in particular, are always positive and the origin is located at the bottom northwest corner of the map; the coordinates count upwards as you move more southerly or easterly from that point.</p>
<p >The engine uses a <b>left-handed</b> coordinate system, which is the opposite chirality from typical 3D coordinate systems used in math and engineering. This means that the positive orientation is clockwise, and cross products follow the left hand rule. This makes the game's coordinates follow the compass orientation well and is perhaps more intuitive for those used to maps where degrees count clockwise, but be aware that the usual identities for right handed systems are mirrored in this coordinate system.</p>
<p >Zero yaw degrees in the engine's coordinate system is facing along the +y axis; the +x axis is at 270 degrees (or to the left side of the y axis, hence the name of the coordinate system); pitch is measured as an altitude where 0 degrees is the horizon, the +z axis is at 90 degrees, and the -z axis is at -90 degrees.</p>
<p >Position coordinates for valid geometry is always positive, as all cubes must be placed NE of the origin, located in the lower SE corner of the map. This should somewhat simplify coordinate calculations, but is mostly there because the root octree node is most easily represented with a corner at (0,0,0) rather than trying to be centered. As a result, larger maps will have their greater extent at larger coordinates; a smaller map will occupy the SE corner of a larger map.</p>
<div class="fragment"><div class="line"> +z                   +z</div>
<div class="line">  |   +x               |</div>
<div class="line">  |  /                 |</div>
<div class="line">  | /                  |______+y</div>
<div class="line">  |/_____+y           /</div>
<div class="line">                     /</div>
<div class="line">                    /</div>
<div class="line">                  +x</div>
<div class="line">LH Coordinates    RH Coordinates</div>
<div class="line">  Clockwise      Counterclockwise</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
1.3.3 Mathematical Notes</h3>
<p >As a 3D engine is largely defined in terms of vectors and linear algebra, some understanding of these concepts is very helpful in understanding positions and transformations in the engine as well as the rendering machinery that renders images to the screen.</p>
<p >A vector is a set of multiple scalars (standard numbers) which together represent a multidimensional location in some space. This space does not have to be positional, as concepts like colors are usually also represented as a vector (components are <code>R</code>ed, <code>G</code>reen, and <code>B</code>lue). Most vectors in Libprimis are three dimensional, but second dimensional, fourth dimensional, complex (quaternions) and dual (dualquats) are also represented.</p>
<p >A particular notational standard which will always be implicit is the difference between <em>speed</em> and <em>velocity</em>. Velocity is a vector, which means it carries a direction along with its size. On the other hand, speed is merely the size of the velocity vector, and does not imply a particular direction.</p>
<p >The complex objects, quaternions and dual quaternions, are not strictly vectors, but exist in a higher dimensional space than standard scalars in a similar way. The structure of the spaces in which these values live is particularly convenient for the constrained values that kinematics problems have, and as such are particularly useful in animation and rotation transformations.</p>
<p >Quaternions have four values, designated x, y, z, w; dual quaternions have similarly their eight values seperated into dual numbers which are each designated x, y, z, w.</p>
<h3><a class="anchor" id="autotoc_md26"></a>
1.3.4 Colors</h3>
<p >Colors which are defined past 0xFFFFFF (hex color for white) are generally passed as a set of three paramaters <code>R G B</code> where <code>1.0 1.0 1.0</code> is 0xFFFFFF. These colors tend to have <code>1.0 1.0 1.0</code> as the default and are expected to vary upwards as much as downwards in practice.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
1.4 Program Structure</h2>
<p >The Imprimis project is, at its highest level, organized into four main projects as well as a pair of utilities which are perhaps not considered direct members of the engine.</p>
<div class="fragment"><div class="line">/--------------------+-----------------------------------------------------------\</div>
<div class="line">|   Serverside       |                     Clientside                            |</div>
<div class="line">+--------------------+-----------------------------------------------------------+</div>
<div class="line">| +--------+  (A)    |                                                           |</div>
<div class="line">| | Master +---------+------\                                                    |</div>
<div class="line">| | Server |         |      |                                                    |</div>
<div class="line">| +--------+         |      v                                                    |</div>
<div class="line">|     ^              |  +--------+   +--------+   +--------+                     |</div>
<div class="line">|     |  +--------+  |  |        |   |        |   |        |                     |</div>
<div class="line">|     +--+ Game   |&lt;-+-&gt;|        |   |        |   |        |   +--------------+  |</div>
<div class="line">|     |  | Server |  |  |        |   |        |   |        +--&gt;| Window Output|  |</div>
<div class="line">|     |  +--------+  |  |        |   |        |   | Simple |   +--------------+  |</div>
<div class="line">|     |              |  |  Game  |   | Game   |   | Direct |                     |</div>
<div class="line">|  (B)|  +--------+ (C) |  Code  |(D)| Engine |(E)| Media  |(F)+--------------+  |</div>
<div class="line">|     +--+  Game  |&lt;-+-&gt;|        |&lt;-&gt;|        |&lt;-&gt;| Layer  +--&gt;| Sound Output |  |</div>
<div class="line">|     |  | Server |  |  |        |   |        |   | (SDL)  |   +--------------+  |</div>
<div class="line">|     |  +--------+  |  |        |   |        |   |        |                     |</div>
<div class="line">|     |              |  |        |   |        |   |        |   +--------------+  |</div>
<div class="line">|     |  +--------+  |  |        |   |        |   |        |&lt;--+  User Input  |  |</div>
<div class="line">|     \--+  Game  |&lt;-+-&gt;|        |   |        |   |        |   +--------------+  |</div>
<div class="line">|        | Server |  |  |        |   |        |   |        |                     |</div>
<div class="line">|        +--------+  |  +--------+   +--------+   +--------+                     |</div>
<div class="line">|                    |      ^                                                    |</div>
<div class="line">|                    |      |(G)                                                 |</div>
<div class="line">|                    |      v                                                    |</div>
<div class="line">|                    |  +--------+                                               |</div>
<div class="line">|                    |  | Local  |                                               |</div>
<div class="line">|                    |  | Server |                                               |</div>
<div class="line">|                    |  +--------+                                               |</div>
<div class="line">\--------------------+-----------------------------------------------------------/</div>
</div><!-- fragment --><ul>
<li>A: Master server provides a list of game servers to the game code via enet.</li>
<li>B: Game servers register to a master server via enet.</li>
<li>C: Game servers can be connected to a client's game via enet.</li>
<li>D: The game engine's behavior is controlled by the game code.</li>
<li>E: The Simple DirectMedia layer library handles input/output.</li>
<li>F: Display, sound, and user inputs get handled by SDL.</li>
<li>G: Local gameplay can be run through a game server hosted clientside.</li>
</ul>
<p >The components of the system handled by the Libprimis project is the:</p>
<ul>
<li>Game engine: core routines needed for the gamecode to run a game</li>
<li>Game code: an actual game written using the facilities written in the engine</li>
<li>Game server: a locally or remotely hosted server that manages game clients</li>
<li>Master server: a service that provides a list of game server names to clients</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
1.5 File Structure</h2>
<p >Libprimis' files are organized essentially into three folders, which carry out largely different roles in the application. The folder containing the engine proper, naturally, is called <code>/engine</code>. There is also a folder for shared library-like functionality in <code>/shared</code> while the game code is located in a folder called <code>/game</code>.</p>
<h3><a class="anchor" id="autotoc_md29"></a>
1.5.1 `/engine` files</h3>
<p >The engine's core functionality is implemented in the <code>engine</code> folder. This folder is itself separated into four main catagories, the scope of which is briefly described below:</p>
<h4><a class="anchor" id="autotoc_md30"></a>
`/interface`</h4>
<p >The interface folder contains the source code used for user-interfacing purposes such as the UI system, scripting, sound, and input.</p>
<ul>
<li><code>command.cpp</code> scripting language (Cubescript) implementation</li>
<li><code>console.cpp</code> ingame console support</li>
<li><code>input.h/cpp</code> key/cursor input handling</li>
<li><code>menus.cpp</code> hardcoded UI menu functionality</li>
<li><code>sound.cpp</code> sound handling and support</li>
<li><code>textedit.h</code> text box UI functionality</li>
<li><code>ui.cpp</code> Cubescript user interface functionality</li>
</ul>
<h4><a class="anchor" id="autotoc_md31"></a>
`/model`</h4>
<p >The <code>model</code> folder contains headers that implement functionality required to parse different model formats. There are no source code files in this folder, and this folder is only included by <code>rendermodel.cpp</code>, located in <code>render</code>.</p>
<ul>
<li><code>animmodel.h/cpp</code> generic animated model support</li>
<li><code>hitzone.h</code> model hitboxes</li>
<li><code>md5.h</code> md5 model format support</li>
<li><code>model.h</code> generic model support</li>
<li><code>obj.h/cpp</code> obj (wavefront) model format support</li>
<li><code>ragdoll.h/cpp</code> skeletal model ragdoll support</li>
<li><code>skelmodel.h/cpp</code> generic skeletal model support</li>
<li><code>vertmodel.h</code> generic vertex model support</li>
</ul>
<h4><a class="anchor" id="autotoc_md32"></a>
`/render`</h4>
<p >The <code>render</code> folder contains the core rendering code used to implement the visual effects in the engine.</p>
<ul>
<li><code>aa.h/cpp</code> antialiasing functionality</li>
<li><code>ao.h/cpp</code> screenspace ambient occlusion functionality</li>
<li><code>csm.h/cpp</code> cascaded shadow maps (for sunlight)</li>
<li><code>grass.h/cpp</code> grass rendering on octree geometry</li>
<li><code>hdr.h/cpp</code> high dynamic range &amp; tonemapping</li>
<li><code>normal.h/cpp</code> normal maps &amp; normal map interpolation</li>
<li><code>octarender.h/cpp</code> octree geometry rendering</li>
<li><code>radiancehints.h/cpp</code> radiance hints (global illumination)</li>
<li><code>rendergl.h/cpp</code> lower-level renderer core</li>
<li><code>renderlights.cpp</code> point light &amp; sunlight rendering</li>
<li><code>rendermodel.h/cpp</code> player, world model rendering</li>
<li><code>renderparticles.h/cpp</code> billboard particle rendering</li>
<li><code>rendersky.h/cpp</code> skybox &amp; other parallax free sky effects</li>
<li><code>rendertext.h/cpp</code> ui text rendering</li>
<li><code>renderva.h/cpp</code> octree geometry vertex array rendering</li>
<li><code>renderwindow.h/cpp</code> window handling</li>
<li><code>shader.cpp</code> glsl shader handling</li>
<li><code>stain.h/cpp</code> dynamic stain creation and rendering</li>
<li><code>texture.h/cpp</code> world geometry texture application</li>
<li><code>water.h/cpp</code> water material &amp; its fx (screenspace reflection etc.)</li>
</ul>
<h4><a class="anchor" id="autotoc_md33"></a>
`/world`</h4>
<p >The <code>world</code> folder contains code creating and handling the ingame world, including entity, player, particle, and physics support.</p>
<ul>
<li><code>bih.h/cpp</code> bounded interval hierarchy (model collision)</li>
<li><code>dynlight.cpp</code> light entities which move around on the level</li>
<li><code>explosion.h</code> explosion effects</li>
<li><code>light.h/cpp</code> light entity support</li>
<li><code>material.cpp</code> in-world special materials (water, lava, etc.)</li>
<li><code>mpr.h</code> minkowski portal refinement (model collision)</li>
<li><code><a class="el" href="octa_8h.html">octa.h</a>/cpp</code> octree geometry for the world</li>
<li><code>octaedit.cpp</code> octree modification by clients</li>
<li><code>physics.cpp</code> player model modification</li>
<li><code>raycube.h/cpp</code> octree geometry querying</li>
<li><code>world.h/cpp</code> world handling and modification</li>
<li><code>worldio.cpp</code> world loading and saving</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
1.6 System Contexts</h2>
<p >The Libprimis engine, like any other program, is designed for particular underlying hardware and software contexts. The Libprimis engine does not especially target a huge breadth of hardware and operating system contexts, less than even its predecessor engines, as a result of Libprimis' focus on providing good support to the platforms it does target.</p>
<h3><a class="anchor" id="autotoc_md35"></a>
1.6.1 Operating System</h3>
<p >Libprimis officially supports only the 64-bit Windows and Linux platforms. While a 64-bit OS is not strictly required to implement the engine, 32-bit OSes have fallen from widespread use and as a result are not part of what the engine explicitly targets.</p>
<p >The macOS operating system is not supported by the engine, for a handful of reasons:</p>
<ul>
<li>the macOS system charges developers to distribute programs widely on macOS</li>
<li>macOS has deprecated OpenGL support, required for the game to run</li>
<li>macOS is moving away from x86 and commodity CPUs &amp; GPUs</li>
</ul>
<h3><a class="anchor" id="autotoc_md36"></a>
1.6.2 Hardware</h3>
<p >Libprimis currently targets only the x86-64 instruction set, widely used by desktops and laptops. Libprimis does not currently target ARMv8 (used by mobile devices) or POWER architectures which are not widely used for gaming.</p>
<p >Libprimis only supports little-endian bit ordering and as a result lacks the capabilities to run on big-endian systems such as the aformentioned POWER.</p>
<p >For graphics processing, hardware capable of supporting the OpenGL 4.0 standard is required; this includes graphics at least as new as Intel Ivy Bridge, AMD's Northern Islands (HD 5000 series), or Nvidia's Fermi (GTX 400 series). Older hardware support is omitted as few cards of this era are capable of running Libprimis at reasonable frame rates.</p>
<p >The engine does not require the SSSE3 (Supplemental Streaming SIMD Extension 3) extensions required of many games and as a result can run on Phenom era processors without issue.</p>
<h4><a class="anchor" id="autotoc_md37"></a>
Performance Considerations</h4>
<p >The Libprimis engine is single-threaded, making multicore CPUs irrelevant to the engine's performance; therefore, any big-core (non Atom or Jaguar based) CPU since around 2010 should be easily adequate to run well-designed levels on Libprimis.</p>
<p >At least two gigabytes of RAM is recommended to run the game, while four or more is easily sufficient to fully utilize the engine.</p>
<p >Nearly all graphics cards that support the OpenGL 4.0 standard should be able to run Libprimis at reasonable speeds, though a card of the RX 460/GTX 950 class is needed to bump graphics up to high levels.</p>
<h1><a class="anchor" id="autotoc_md38"></a>
2. World</h1>
<p >The <em>world</em> is the name for the level that the game is played on, including the octree geometry, materials, and cloud/skyboxes. The world does include the static entities as well which are placed upon it, but those are instead described in the third chapter, which covers entities and actors in more detail.</p>
<p >The world's biggest feature is the octal tree that makes up the primary level geometry. This geometry has the advantage of being easily occludable and simple to modify on the fly, as opposed to models which are placed on the world as static entities.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
2.1 Octree Geometry</h2>
<p >The Libprimis engine's geometry system is very different than most engines and has different strengths and weaknesses with respect to typical polygon soup engines such as Unreal or the Quake family of engines. Libprimis' octal tree geometry does not record map vertices in terms of typical positon vectors, as the vast majority of 3D rendering software uses, instead opting to use an octal tree format.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
2.1.1 Octree Data Structure &amp; Cube Geometry</h3>
<p >Libprimis stores its data in an octal tree, in which each cube of edge length <em>l</em> is divided into eight cubes with edge length <em>l</em>/2. This allows for a level to be efficiently and recursively divided into smaller and smaller pieces. The power of this data structure is that large, faraway objects can occupy relatively fewer nodes in the data tree than objects in the level have.</p>
<p >The <code>gridpower</code> of a particular octree node (henceforth called simply a "cube") is an indication of what level it is on the octal tree and therefore also its size. A gridpower 0 cube is 12.5 cm on edge (~5 inches), a gridpower 1 cube is 25cm (~10 inches) on edge, and a gridpower <em>n</em> cube is 2^(<em>n</em>-3) m on edge.</p>
<p >Level sizes are also defined most conveniently in terms of gridpower; the default map is 2^10 = 2^7m = 128m on edge. Due to limitations of the renderer's z-buffer precision, distances beyond about half a kilometer on edge are not generally recommended.</p>
<p >Cubes in Libprimis, the most basic form of geometry in the game, therefore occupy the octree; instead of vertices in other engines being determined by their 3D vector from the origin, a cube's place in the octal tree determines its location.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
2.1.2 Child Nodes</h3>
<p >As mentioned above, each node can have <em>children</em> defined for them which themselves can have their own child nodes. The maximum depth of this tree is equal to the <code>mapsize</code>: a map of size 2^10 = 1024 cubes (128m square) can have child nodes up to 10 deep.</p>
<div class="fragment"><div class="line">       ^ +z</div>
<div class="line">       |</div>
<div class="line">     __________</div>
<div class="line">    /  4 /  5 /</div>
<div class="line">   /____/____/.</div>
<div class="line">  /  6 /  7 / .</div>
<div class="line"> /____/____/  .</div>
<div class="line">.    _____.___.</div>
<div class="line">.   /  0 /. 1 /     +x</div>
<div class="line">.  /____/_.__/    -&gt;</div>
<div class="line">. /  2 / 3. /</div>
<div class="line">./____/___./</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    / +y</div>
<div class="line">   |/</div>
</div><!-- fragment --><p >The assignment of child nodes is outlined above. The node with the lowest x,y,z coordinates is assigned as child node #0, and counts upwards to node 7, which is at the largest x,y,z coordinates. A child node might be found in this way within the engine:</p>
<div class="fragment"><div class="line">level 0 128m                   worldroot</div>
<div class="line">                 __________________|_________________</div>
<div class="line">                 |    |    |    |    |    |    |    |</div>
<div class="line">level 1 64m      0    1    2    3    4    5    6    7</div>
<div class="line">                             __________________|_________________</div>
<div class="line">                             |    |    |    |    |    |    |    |</div>
<div class="line">level 2 32m                  0    1    2    3    4    5    6    7</div>
<div class="line">                                    __________________|_________________</div>
<div class="line">                                    |    |    |    |    |    |    |    |</div>
<div class="line">level 3 16m                         0    1    2    3    4    5    6    7</div>
<div class="line">                       __________________|_________________</div>
<div class="line">                       |    |    |    |    |    |    |    |</div>
<div class="line">level 4 8m             0    1    2    3    4    5    6    7</div>
<div class="line">                                                     ^</div>
<div class="line">                                                     | (6,5,1,6)</div>
<div class="line">                                                This is an 8*8*8m cube node.</div>
</div><!-- fragment --><p >The "gridpower" of a cube is related to the distance down the tree that a cube is, and therefore its size as a power of two. The bottom of the tree is always at gridpower 0, and is located eleven rungs down (0,1,2,3,4,5,6,7,8,9,10) the world octree on a standard power 10 map (128m on edge).</p>
<p >In this view, the ease of discarding smaller nodes is apparent: the cube selected (7,5,1,6) could be discarded easily if it was found that cube (7,5) was occluded, since its "address" includes all the larger cubes that occupy its volume. This is very fast compared to a pile of vectors which need to be individually treated in order to ensure they can be excluded from the render process.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
2.1.3 World Root</h3>
<p >The worldroot, indicated in the octal tree diagram above at the top, is the master cube inside which all geometry fits. Geometry may not leave the area bounded by the worldroot cube, as all geometry is carved out of the worldroot's children nodes (all cubes in a level are child cubes of the worldroot cube).</p>
<p >Because of this, maps always have the following properties:</p>
<ul>
<li>Maps are always square. Cube nodes are all sqaure, and thus the largest cube node is as well.</li>
<li>Maps are of fixed size. The size of the worldroot defines the map's size.</li>
<li>Maps' range of gridpowers allowed is determined by the size of the worldroot cube.</li>
</ul>
<h4><a class="anchor" id="autotoc_md43"></a>
Map Expansion</h4>
<p >There is a command, <code>mapenlarge</code>, that can grow a map such that the worldroot takes up a larger volume. The existing map, accordingly, is placed as child 0 of the new world root, leading to the map expansition occupying space in the +x, +y, and +z direction from the location of the existing map. This may be slightly inconvenient for those seeking to expand the scenery bounds of their level uniformly; a copy and paste of the geometry is needed to re-center the old level if desired.</p>
<h3><a class="anchor" id="autotoc_md44"></a>
2.1.4 Cube Manipulation</h3>
<p >While octree subdivision allows for the inclusion of small pieces of geometry, this is not on its own adequate due to the fact that octree nodes are, well, cubes. To allow for maps which have shapes that are not all boxes, Libprimis, like other games in the Cube family, allows for limited, discrete deformation of octree nodes.</p>
<p >Each corner, of which there are eight on a cube, can be deformed along all three directions in steps of 1/8th of the total cube size. This allows for decent approximations of many curves when done carefully, and using different gridpowers prudently can allow for some limited compound curvature.</p>
<p >This deformation, when carried out by all four corners of a cube, can allow for faces which do not align with their boundaries; indeed, all six faces can be deformed in this way to yield a deformed cube that does not touch its neighbors. The "integrity" of the octree node, however, remains intact, and no other geometry can occupy the cube which has been deformed. This set of limitations can be summarized with the following statement:</p>
<ul>
<li>Every octree node is defined to have eight vertices and twelve faces.</li>
<li>Each vertex can only be found at one of 512 discrete points within the node.</li>
<li>Textures always get an entire face of an octree node.</li>
<li>Textures are projected from the node normal, not the deformed surface normal.</li>
<li>Cubes' deformed shapes may not extend past their original undeformed volume.</li>
</ul>
<p >Therefore, the only way to increase detail in a given area when using cube geometry is to increase the octree node density (by using a smaller gridpower).</p>
<p >For more information on texture projection, see §2.3.3.</p>
<h3><a class="anchor" id="autotoc_md45"></a>
2.1.5 Remipping and Subdivision</h3>
<h4><a class="anchor" id="autotoc_md46"></a>
Subdivision</h4>
<p >The engine automatically attempts to subdivide cubes when a user attempts to place a cube within a node which is of a larger gridpower. This means that many types of cube deformation are no longer possible, causing erratic and generally poor approximations of the prior form. It is recommended to take care when placing new cubes in proximity to existing geometry of a larger gridpower, as this can inadvertently cause unseemly changes to the level's geometry.</p>
<h4><a class="anchor" id="autotoc_md47"></a>
Remipping</h4>
<p >The engine, when given a <code>remip</code> command, attempts to merge nodes with redundant vertices together such that the renderer has less faces to deal with when later rendering the scene. This reduces the map size and improves performance.</p>
<p >The amount of remipping intensity is defined by the <code>maxmerge</code> command, which determines the maximum gridpower that can be simplified. Having this value too high causes large surfaces to occlude poorly, as the entire face has to be textured.</p>
<h4><a class="anchor" id="autotoc_md48"></a>
Commands</h4>
<p ><code>remip</code>: performs a remip calculation on the level <code>maxmerge N</code>: sets the maximum merge gridpower to N</p>
<h2><a class="anchor" id="autotoc_md49"></a>
2.2 Materials</h2>
<p >There are several materials in Libprimis which are capable of modifying their volume's properties. Materials in general are combinable (though there are many exceptions) so that multiple effects on the geometry can be combined. Because materials do not have the same deformation ability as geometry, materials are restricted to occupying rectangular shapes and cannot approximate the forms that geometry can.</p>
<p >The most visible apparent materials are the water and glass materials. Water and glass materials (of which there are eight, four of each type) create rectangular volumes of water or glass in their selected regions. Water in particular has features like screenspace reflection/refraction and caustics applied to it in the renderer; glass, on the other hand, allows for screenspace refractive as well as specular effects.</p>
<p >A more versatile but slower type of transparency is alpha material, which flags cube geometry as transparent. The texture's properties determine the effects of marking geometry alpha as opposed to the variables of the material itself; alpha merely tells the engine what areas to treat specially as transparent.</p>
<p >The remaining three types of materials have no visual effect and instead only act on actors and objects in the level. Death material kills all who enter its volume; clipping keeps players out while letting particles through, and noclip keeps geometry from hampering the travel of projectiles and players.</p>
<h3><a class="anchor" id="autotoc_md50"></a>
2.2.1 Air</h3>
<p >Air, the name for the lack of materials, unsurprisingly is the default "material" for the level. Air can be "placed" by <code>/editmat air</code> or <code>/air</code> whereupon it removes all previously existing materials flagged for that selection.</p>
<p >The name "air" does not imply that there is any oxygen mechanics in the game and there is no material representing the lack of air.</p>
<h3><a class="anchor" id="autotoc_md51"></a>
2.2.2 Water</h3>
<p >Water, the material with the largest change with respect to prior engines, has four types that can be modified seperately to apply in different situations on the map. As water is a particularly complex material to physically represent, there are many visual effects provided in the engine which can be tuned for particular situations.</p>
<p >Water is the only place in which screenspace reflection is used in game; water materials also have options for caustics, reflection, fog, and environment mapping to complement this. The sides of water material have different properties (such as lacking screenspace reflection) and are controlled by a differnt set of variables (the <code>water&lt;N&gt;fall</code> set).</p>
<p >Commands which apply to the four water types seperately are designated <code>water&lt;N&gt;</code> where N is the water material being edited. There are four water materials, and the first one does <em>not</em> get appended with a "1" like 2/3/4 all do.</p>
<h4><a class="anchor" id="autotoc_md52"></a>
Commands</h4>
<ul>
<li><code>causticscale</code></li>
<li><code>causticmillis</code></li>
<li><code>causticcontrast</code></li>
<li><code>causticoffset</code></li>
<li><code>caustics</code></li>
<li><code>water&lt;N&gt;color</code></li>
<li><code>water&lt;N&gt;deepcolor</code></li>
<li><code>water&lt;N&gt;deepfade</code></li>
<li><code>water&lt;N&gt;refractcolor</code></li>
<li><code>water&lt;N&gt;fog</code></li>
<li><code>water&lt;N&gt;deep</code></li>
<li><code>water&lt;N&gt;spec</code></li>
<li><code>water&lt;N&gt;refract</code></li>
<li><code>water&lt;N&gt;fallcolor</code></li>
<li><code>water&lt;N&gt;fallrefractcolor</code></li>
<li><code>water&lt;N&gt;fallspec</code></li>
<li><code>water&lt;N&gt;fallrefract</code></li>
<li><code>waterreflect</code></li>
<li><code>waterreflectstep</code></li>
<li><code>waterlod</code></li>
<li><code>watersubdiv</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md53"></a>
2.2.3 Glass</h3>
<p >Another one of the four-variant materials, and the second most interesting (after water) with respect to engine features, glass is a cheap and effective way to create transparent geometry. As opposed to alpha material, glass is restricted to rectangular volumes (as with all materials) and therefore is somewhat less flexible; additionally glass material is not capable of backface transparency like glass is. However, because glass material does not require rerendering of parts of the level like alpha does.</p>
<p >Because glass material is expected to be used largely in vertical situations where screenspace reflection is a poor choice, it does not have screenspace reflection support and instead relies entirey on environment mapping and specular mapping for its reflective appearence. This does mean that glass has to be careful about how it is placed such that it falls within the radius of an environment map entity. Like water and alpha materials, however, glass is capable of screenspace refraction, useful for nonflat materials.</p>
<p >In itself, glass material does not block movement, but in practice it always does because clipping material is mandatory for all types of glass. The engine will automatically place clip wherever glass is placed.</p>
<h4><a class="anchor" id="autotoc_md54"></a>
Commands</h4>
<ul>
<li><code>glass&lt;N&gt;color</code> Tint color of the glass material</li>
<li><code>glass&lt;N&gt;spec</code> Specularity (glossiness) scale of the glass material</li>
<li><code>glass&lt;N&gt;refract</code> Refraction (light distortion behind) of the glass material</li>
</ul>
<h3><a class="anchor" id="autotoc_md55"></a>
2.2.5 Clip</h3>
<p >An entirely transparent material, clip, unlike the materials prior, does not affect the rendering of the scene in any way. Clip, instead, impedes the ability for actors (players, bots) to enter their volumes; it allows for the map to be securely blocked off from leaving even without geometry placed. Clip material is also recommended for cases where the existing geometry has troublesome collision, such as trellis or crosshatched geometry. Clip is also always placed wherever glass is, to make it impossible to phase through.</p>
<p >Clip, however, notably does <em>not</em> impede the progress of particles or projectiles, which allows it to be used for map boundaries without fear of random projectiles bouncing or dying on collision with its bounds. If it is required that projectiles be deleted upon contact, using death material in tandem with clip is a viable solution.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
2.2.6 Noclip</h3>
<p >The opposite material to clip (unsurprisingly), noclip instead permits the passage of actors through otherwise impenetrable geometry. Noclip additionally allows projectiles through surfaces, making the enclosed volume get treated essentially as air instead of having whatever collision the geometry within has.</p>
<p >As a result, noclip is of no effect for volumes not containing geometry; there must be geometry within the noclip's volume for it to take effect.</p>
<p >Using noclip effectively and not having immersion-breaking visibility problems generally limits its use to relatively small applications, like flattening out a floor or smoothing a wall out so that it is not obstructing travel. When placing noclip, it is advisable to check it by spawning into the level and making sure that there is no unseemly visibility issues (where you can see through the wall) that would break immersion.</p>
<h3><a class="anchor" id="autotoc_md57"></a>
2.2.7 Death</h3>
<p >Death material forces the suicide of those players who enter its bounds, instantly killing them.</p>
<p >Death material also destroys particles and projectiles which enter its midst, which is potentially useful for culling unnecessary particles that enters its region.</p>
<p >The bottom of the map (z &lt; 0) also acts as death material and players who leave the bottom of the map automatically are killed. No such effect takes place on the sides or top of the map volume.</p>
<h3><a class="anchor" id="autotoc_md58"></a>
2.2.8 No GI</h3>
<p >No GI material flags its volume as not being lit by global illumination. This does not have a material impact (or improvement) in performance but may be useful to combat artifacts in the low-resolution global illumination algorithm.</p>
<p >Note that those regions beyond the radiance hints far plane (<code>rhfarplane</code>) will be lit regardless of their No GI status. Keep this in mind whenever placing long-distance radiance hints.</p>
<h3><a class="anchor" id="autotoc_md59"></a>
2.2.9 Alpha</h3>
<p >Alpha material is the more versatile but slower companion to glass for the creation of transparency. Alpha material draws cube geometry within its bounds as transparent, allowing for transparent shapes in forms other than rectangular boxes.</p>
<p >Alpha material has its material properties dependent upon the flagged settings of the geometry contained therein; using <code>valpha</code> allows for changing a texture's transparent-ness. The material on its own has no flags or other related commands to modify its behavior.</p>
<p >Alpha material does not support continuous variable opacity, and the opacity is always constant for a given texture. While this is certainly a limitation, typical transparent objects like windows generally have constant opacity across their full area.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
2.3 Textures</h2>
<p >The faces of cubes within the game can be given textures on a cube face by cube face basis, allowing for immersive, complete scenes to be generated via cube geometry.</p>
<p >Textures are applied to the six faces of the cube with a simple planar projection; as a result, there is distortion when cubes themselves are distorted. This can be allieviated with the more expensive <code>triplanar</code> shader, but that is beyond the scope of this section.</p>
<p >Each cube has a texture defined for each of its six faces; this means that "buried" geometry will after revision cause the storage of meaningless texture information for invisible geometry. For this reason, there is a command <code>fixinsidefaces</code> which can set all invisible faces to the default texture.</p>
<h4><a class="anchor" id="autotoc_md61"></a>
Commands</h4>
<ul>
<li><code>fixinsidefaces [vslot]</code> Sets all invisible faces to the vslot given.</li>
</ul>
<h3><a class="anchor" id="autotoc_md62"></a>
2.3.1 Texture Slots</h3>
<p >Textures are registered to a file that accompanies the map, generally named the same as the map file and with the <code>.cfg</code> extension. Texture slots are for unique shader combinations (for a description of the shaders see the section on texture rendering) and as a result at least one physical slot is required for each distinct texture in the game. A texture slot declares the following:</p>
<ul>
<li>Shaders used in the texture</li>
<li>Modifications to shader paramaters</li>
<li>Relevant texture maps</li>
</ul>
<p >An example of a typical texture declaration is shown below.</p>
<div class="fragment"><div class="line">setshader bumpenvspecmapglowworld</div>
<div class="line">setshaderparam envscale  0.7 0.7 0.7</div>
<div class="line">   texture 0 <span class="stringliteral">&quot;nieb/complex/light01_c.png&quot;</span></div>
<div class="line">   texture n <span class="stringliteral">&quot;nieb/complex/light01_n.png&quot;</span></div>
<div class="line">   texture s <span class="stringliteral">&quot;nieb/complex/light01_s.png&quot;</span></div>
<div class="line">   texture g <span class="stringliteral">&quot;nieb/complex/light01_g.png&quot;</span></div>
</div><!-- fragment --><p >This shader is set to <code>bumpenvspecmapglowworld</code>, meaning it uses bump (normal), environment mapping, specular mapping, and glow mapping. The <code>world</code> on the end is to declare it as a cube geometry shader as opposed to a decal. Afterwards, the four relevant maps are provided for the different shaders that are to be applied with the <code>texture</code> command;</p>
<ul>
<li><code>0/c</code> declares a diffuse map</li>
<li><code>n</code> declares a normal map</li>
<li><code>s</code> declares a specular map</li>
<li><code>z</code> declares a height (parallax) map</li>
<li><code>g</code> declares a glow map</li>
</ul>
<p >These definitions of textures are largely set beforehand and then called with <code>texload</code> upon running the map's config (automatically run at map load); most textures have only a couple of possible appropriate shader combinations anyways.</p>
<h3><a class="anchor" id="autotoc_md63"></a>
2.3.2 Virtual Slots</h3>
<p >Virtual slots encode simple manipulation of textures, such as coloration, scale, rotation, and orientation. These do not require declaration upon map generation and are generally created dynamically ingame after the execution of a <code>v</code> command. Virtual slots (vslots) then save only the parent texture index and the modifications done to it; they save significant memory space by not requiring a modified copy to be stored in video memory.</p>
<p >The modifications that a vslot can store are described below in the V-command section.</p>
<h3><a class="anchor" id="autotoc_md64"></a>
2.3.3 Texture Projection</h3>
<p >The standard scaling of textures is such that there are 512 linear pixels per gridpower 5 cube, leading to a density of 512/32 = 16 pixels per power 0 cube or 512/4 = 128 pixels per meter. This is somewhat low but largely sufficient for generic areas which the player does not find themselves particularly close to, but may be insufficient for areas the player is near to; for this, the V-command <code>vscale</code> is very useful.</p>
<p >Textures which are not square are projected faithfully and there is no stretching of the shorter axis; this means that trim textures can be made skinny and narrow if desired to save space.</p>
<p >Textures are projected onto the parent node normals and not the deformed surface normals, which causes distortion of the texture when it is heavily distorted. This effect additionally causes attempted blending of faces (like when trying to make rounded organic geometry) to have an unseemly seam along these boundaries, as these boundaries delimit different texture projection differences.</p>
<p >This problem can be solved with the <code>triplanar</code> shader, which forces textures to be projected in three different directions such that the true normal caused by the distorted cube can be found accurately.</p>
<h3><a class="anchor" id="autotoc_md65"></a>
2.3.4 Texture Slot Properties</h3>
<p >The V-commands are a set of texture modification commands that allow for textures to be flipped, rotated, scaled, tinted, and offset as necessary. These commands, when run while in the editor, create new vslots with the modified behavior.</p>
<p >The tex-commands are the corresponding commands for standard texture slots and have the same effect; these are declared for physical texture slots as opposed to being dynamically assigned to virtual slots (vslots).</p>
<p >Other than their means of assigning texture behavior to slots, however, the two commands are otherwise identical in their behavior. V-commands are the ones used ingame; tex-commands are generally placed in texture definitions.</p>
<h4><a class="anchor" id="autotoc_md66"></a>
`texalpha &lt;front&gt; &lt;back&gt;`, `valpha &lt;front&gt; &lt;back&gt;`: transparency modifiers</h4>
<p ><code>alpha</code> sets the amount of transparency to render the texture if it is within the volume of placed alpha material. The property has no effect otherwise, and so modifying this should only be done while the texture is inside alpha material such that the effects of changing <code>alpha</code> are apparent.</p>
<p >Textures are set to <code>0.5 0</code> alpha by default, meaning they are halfway opaque. Notably, the second parameter is zeroed out, such that the backface alpha feature of the engine is not enabled. Backface alpha is the closest thing the deferred renderer of Tesseract (deferred renderers in general have trouble dealing with alpha in expedient ways) to multiple layers of alpha, though it is a somewhat limited approach which does not lend itself to wide applicability.</p>
<p >Backface alpha allows the far side of the geometry to also be rendered along with the standard front face that is rendered by default. Backface alpha requires another geometry pass in the renderer and <em>is</em> measurably slower than leaving it off, but also is the only way to simulate glass-behind-glass in levels.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
`texangle &lt;index&gt;`, `vangle &lt;index&gt;` : fine texture rotation</h4>
<p ><code>angle</code> rotates the texture by a given angle; capable of rotating textures by arbitrary amounts through 360 degrees. If needed, this can be combined with <code>rotate</code> which works by a different mechanism (and is the only way to get flipped/transposed textures).</p>
<h4><a class="anchor" id="autotoc_md68"></a>
`texcolor &lt;R&gt; &lt;G&gt; &lt;B&gt;`, `vcolor &lt;R&gt; &lt;G&gt; &lt;B&gt;`: texture tinting</h4>
<p ><code>color</code> changes the color of the texture evenly through the values of the three parameters passed to it. <code>color 1 1 1</code> is the identity operator (has no effect) and values above and below this will change the colors accordingly. As the combination of red, green, and blue is the standard basis for additive colors (like on a monitor), any color can be created by using the three channels appropriately.</p>
<h4><a class="anchor" id="autotoc_md69"></a>
`texoffset &lt;x&gt; &lt;y&gt;`, `voffset &lt;x&gt; &lt;y&gt;`: translational texture offset</h4>
<p ><code>offset</code> offsets a texture by a given number of pixels; this means that higher resolution textures need larger offsets, and that for standard textures, fractional offsets are in powers of 2 (a 1024x texture needs to be offset by 512 to be shifted by half a texture).</p>
<h4><a class="anchor" id="autotoc_md70"></a>
`texrefract &lt;scale&gt; &lt;R&gt; &lt;G&gt; &lt;B&gt;`, `vrefract &lt;scale&gt; &lt;R&gt; &lt;G&gt; &lt;B&gt;`: refract</h4>
<p ><code>refract</code> modifies the refractive behaviors of materials that are within alpha material. Refraction is the distortion of rays or light traveling through a material due to the change in the speed in light at material boundaries, and is handled in Libprimis via screenspace effects. The intensity of the refraction is handled by the <code>scale</code> parameter and the color of the refraction is controlled by the <code>R G B</code> parameters; <code>1 1 1</code> is the default white color.</p>
<h4><a class="anchor" id="autotoc_md71"></a>
`texrotate &lt;index&gt;` `vrotate &lt;index&gt;`: coarse texture rotations/transforms</h4>
<p ><code>rotate</code> transforms a texture by the possible "simple" 2x2 matrix transforms, of which there are seven.</p>
<ul>
<li><b>1</b> rotate 90</li>
<li><b>2</b> rotate 180</li>
<li><b>3</b> rotate 270</li>
<li><b>4</b> flip x</li>
<li><b>5</b> flip y</li>
<li><b>6</b> transpose</li>
<li><b>7</b> flip and transpose</li>
</ul>
<p >Note that flipping and transposing are the same regardless of whether the flip is over the x or y axis.</p>
<p >These transforms are basic means of getting new orientations for situations which do not require the more granular <code>vrotate</code> command and is the only way to flip/transpose textures.</p>
<h4><a class="anchor" id="autotoc_md72"></a>
`texscale &lt;scale&gt;`, `vscale &lt;scale&gt;`: texture scaling</h4>
<p ><code>scale</code> changes the size of the texture linearly along its axes. As a result, a texture at <code>vscale 4</code> takes up four times the area as <code>vscale 2</code> while having linear dimensions twice as great.</p>
<p >The identity setting for <code>scale</code> is <code>scale 1</code>; the default scale factor, perhaps not surprisingly, is unity. The engine does low for scales smaller than unity, which corresponds to downscaling the texture to increase its density. The limits for scaling correspond to powers of two; the minimum is 2^-3 (1/8) and the maximum is 2^3 (8). At these extremes, textures are either way overdetailed (1024 pixels per meter) or way underdetailed (16 pixels per meter).</p>
<p >For most applications, it is recommended that the scaling be kept to powers of 2 such that the texture tiles in sync with the cube grid. Exceptions where other scales may be appropriate include instances where 3/2 scaling is desired for a 3 cube wide area or organic textures which are not intended to noticibly tile.</p>
<h4><a class="anchor" id="autotoc_md73"></a>
`texscroll &lt;x&gt; &lt;y&gt;`, `vscroll &lt;x&gt; &lt;y&gt;`: time-varying translational offset</h4>
<p ><code>scroll</code> causes the texture to take on a linear time-varying offset such that the texture appears to move with respect to the surface it is applied to. The scale for this scrolling effect is such that <code>scroll 1</code> is 1 texture per second; this is usually too large for common scrolling objects (like banners or conveyor belts) and as such fractional values here are most commonly employed.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
2.4 Global Properties</h2>
<p >The world in Libprimis has many global variables that affect the entire level evenly. These include ambient lighting, fog, and skybox settings, as well as more technical aspects such as mipping intensity. This section does not include the global settings for individual materials, as is covered in §2.2.</p>
<h3><a class="anchor" id="autotoc_md75"></a>
2.4.1 Sunlight</h3>
<p >Sunlight, the cheapest form of bulk lighting in the game, is a dynamic light which casts shadows like any other light, but from a projection at infinity. Sunlight therefore projects perfect quadrilaterals from rectangular objects (as opposed to the trapezoids of point lights on the level).</p>
<p >Sunlight is also the only type of light that takes advantage of Libprimis' global illumination capability, as enabling it for standard lights is too expensive. Global illumination by sunlight is capable of providing ambient lighting to partially lit rooms and is faster than using large numbers of on-level point lights.</p>
<p >Sunlight has just four variables controlling its behavior, which set its size, color, and location.</p>
<h4><a class="anchor" id="autotoc_md76"></a>
Commands</h4>
<ul>
<li><code>sunlight &lt;color&gt;</code> Sets the color of the sunlight, passed as a hex color.</li>
<li><code>sunlightpitch &lt;angle&gt;</code> Sets the sun's inclination angle above the horizon.</li>
<li><code>sunlightyaw &lt;angle&gt;</code> Sets the yaw angle (about z axis) of the sunlight.</li>
<li><code>sunlightscale &lt;scale&gt;</code> Sets the intensity scale of the sunlight.</li>
</ul>
<h3><a class="anchor" id="autotoc_md77"></a>
2.4.2 Fog</h3>
<p >Fog is an effect that fades objects to a particular color as the distance to that object grows larger. Fog is useful for creating a closed, damp ambiance, but be aware that it can be easily disabled on client machines, making its use as a balance technique inadvisable in light of its lack of security with respect to its implementation.</p>
<p >Fog also culls the rendering of entities once they pass into the realm of complete obscurance, which is set by the <code>fogcullintensity</code> variable.</p>
<h4><a class="anchor" id="autotoc_md78"></a>
Commands</h4>
<ul>
<li><code>fog &lt;dist&gt;</code> The characteristic distance for the onset of fog effects.</li>
<li><code>fogcolor &lt;color&gt;</code> The color of the fog, as a hex color.</li>
<li><code>fogcullintensity &lt;scale&gt;</code> The intensity by which fog culls entity rendering.</li>
<li><code>fogintensity &lt;scale&gt;</code> The fog effect intensity (lower values -&gt; more fog).</li>
<li><code>fogoverlay</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md79"></a>
2.4.3 Ambient Lighting</h3>
<p >The cheapest type of global lighting, changing the ambient light level for the map makes everything at least as bring as the set ambient level. This reduces contrast however and makes the shadows less deep, so generally using at least global illumination combined with sunlight is preferable whenever possible to high ambient settings. A little ambient, however, is advisible to make the scene not pitch dark anywhere.</p>
<p >Ambient lighting does not require shading resources like sunlight or point lights and so is not a performance issue like the other types of lighting can be.</p>
<h4><a class="anchor" id="autotoc_md80"></a>
Commands</h4>
<ul>
<li><code>ambient</code> Hex color for ambient color, typically dimmer than <code>0x333333</code></li>
<li><code>ambientscale</code> Multiplier for ambient color (usually left at 1)</li>
</ul>
<h3><a class="anchor" id="autotoc_md81"></a>
2.4.4 Skybox</h3>
<p >The skybox is a static rendering of a scene surrounding the map which provides a backdrop to the level. The skybox is a cubemap, a type of environment projection wherein the viewable area around a point (a full sphere) is seperated and projected onto the six faces on a cube. The cubemap projection is particularly convenient for its simplicity of projection for the engine and its relatively low distortion (as opposed to a single-face projection like Mercator) while remaining fairly simple to comprehend.</p>
<p >Skyboxes in Libprimis are passed as a set of six images:</p>
<ul>
<li><b>bk</b>: the backside texture (normal facing south)</li>
<li><b>dn</b>: the bottom texture (normal facing upwards)</li>
<li><b>ft</b>: the front texture (normal facing north)</li>
<li><b>lf</b>: the left texture (normal facing west)</li>
<li><b>rt</b>: the right texture (normal facing right)</li>
<li><b>up</b>: the top texture (normal facing downwards)</li>
</ul>
<p >Note that these are defined for cases in which the yaw of the skybox is 0; that is to say that it it has not been rotationally translated at all. Rotating the sky about the z-axis is possible and changes the orientation of the side faces of the skybox accordingly.</p>
<p >These six textures are loaded whenever the skybox is set: setting <code>skybox foo/bar</code> will automatically load <code>foo/bar_bk</code>, <code>foo/bar_dn</code>, etc. as the skybox. Implicit in the path is the location of skyboxes in <code>/media/sky</code>.</p>
<h4><a class="anchor" id="autotoc_md82"></a>
Commands:</h4>
<ul>
<li><code>skybox &lt;path&gt;</code> Sets the path of the skybox, excluding the _XX and format.</li>
<li><code>skyboxcolor &lt;color&gt;</code> Tints the skybox to the given hex color.</li>
<li><code>skyboxoverbright &lt;scale&gt;</code> Controls how bright highlights in the skybox are.</li>
<li><code>skyboxoverbrightmin &lt;scale&gt;</code> Sets the overbrightness overall of the skybox.</li>
<li><code>skyboxoverbrightthreshhold &lt;scale&gt;</code> Sets min brightness for highlighting.</li>
<li><code>skyboxyaw &lt;angle&gt;</code> Sets the overall orientation of the skybox in the world.</li>
<li><code>skyboxspin &lt;angular vel&gt;</code> Sets the rotation speed of the sky in deg/s.</li>
</ul>
<h3><a class="anchor" id="autotoc_md83"></a>
2.4.5 Cloud Layer</h3>
<p >Additionally, the engine supports a single planar layer of clouds. The "height" of this layer is adjustable, but there is no parallax regardless of height: moving around on the map will not change the relative position of the cloud layer. The cloud layer instead gains its apparent closeness from the rate at which low-inclination clouds become apparently smaller: lower cloud layer heights mean that the center is relatively larger compared to higher cloud layer heights. Additionally, lower cloud layers appear to extend closer to the horizon than higher ones.</p>
<p >Cloud layers are, unlike the cubemap projections that cloudboxes and skyboxes use, able to scroll (have a translational movement with respect to time) in addition to being able to spin about the z-axis. This allows for somewhat realistic cloud movement when done in moderation.</p>
<h4><a class="anchor" id="autotoc_md84"></a>
Commands:</h4>
<ul>
<li><code>cloudalpha &lt;value&gt;</code> Sets the opacity of the cloudlayer (0..1, 1 for opaque).</li>
<li><code>cloudclip &lt;value</code> Sets level of clipping passed to env box draw.</li>
<li><code>cloudcolor &lt;color&gt;</code> Tints the cloudbox to the given hex color.</li>
<li><code>cloudfade &lt;value&gt;</code> Sets the fade rate of the cloudbox.</li>
<li><code>cloudheight &lt;value&gt;</code> Sets the apparent height of the clouds in the sky.</li>
<li><code>cloudlayer &lt;path&gt;</code> Sets the path to the cloud layer, excluding extension.</li>
<li><code>cloudoffsetx &lt;value&gt;</code> Sets the x offset amount, in pixels.</li>
<li><code>cloudoffsety &lt;value&gt;</code> Sets the y offset amount, in pixels.</li>
<li><code>cloudscale &lt;value&gt;</code> Sets the scale factor of the clouds (1 by default).</li>
<li><code>cloudscrollx &lt;value&gt;</code> Sets the x scroll amount, in pixels/s.</li>
<li><code>cloudscrolly &lt;value&gt;</code> Sets the y scroll amount, in pixels/s.</li>
<li><code>cloudsubdiv &lt;value&gt;</code> Sets the number of edges the cloud perimeter has.</li>
<li><code>cloudspin &lt;value&gt;</code> Sets the spin rate of the clouds in the CW direction.</li>
<li><code>cloudyaw &lt;value&gt;</code> Sets the yaw offset angle of the cloud layer.</li>
</ul>
<h3><a class="anchor" id="autotoc_md85"></a>
2.4.6 Atmo</h3>
<p >Atmo is the way that the game can create a procedural skybox such that the sky follows the sun's position and lights itself according to the sun's position. The sun (which as noted in §2.4.1 is set by sunlightpitch/sunlightyaw) determines the location of the atmo sun in the sky, making the atmo skybox always line up with the sun's position and the shadows it throws.</p>
<p >The atmo layer can be blended with the skybox layer with <code>atmoalpha</code> and as such can be blended with complex scenes while still being capable of dynamic positioning whenever needed. Standard skyboxes with fixed light sources are restricted to whatever pitch the light source is placed on the skybox (though the skybox can be rotated about the z direction) and this limits the ability of sunlight to properly light a scene.</p>
<p >Atmo takes many physical parameters which affect the simulated atmosphere that is created. These include the opacity of the air, the size of the planet, the apparent intensity of the light source, and the characteristic color of the sky.</p>
<h4><a class="anchor" id="autotoc_md86"></a>
Commands:</h4>
<ul>
<li><code>atmoalpha &lt;value&gt;</code> Sets the opacity of the atmo layer (0..1, 1 for opaque)</li>
<li><code>atmobright &lt;value&gt;</code> Sets the overall brightness of the atmo sky.</li>
<li><code>atmodensity &lt;value&gt;</code> Sets the diffusion amount of the atmo air.</li>
<li><code>atmohaze &lt;value&gt;</code> Sets the scale of haze at the horizon.</li>
<li><code>atmohazefade &lt;value&gt;</code> Sets the color that the horizon haze fades to.</li>
<li><code>atmohazefadescale &lt;value&gt;</code> Sets the haze transition scale.</li>
<li><code>atmoheight &lt;value&gt;</code> Sets the height of the horizon atmospheric effect.</li>
<li><code>atmoplanetsize &lt;value&gt;</code> Sets the hardness of the atmo transition.</li>
<li><code>atmosundiskbright &lt;value&gt;</code> Sets the brightness of the atmo sun.</li>
<li><code>atmosundisksize &lt;value&gt;</code> Sets the diameter of the atmo sun.</li>
<li><code>atmosunlight &lt;value&gt;</code> Sets the color of the atmo sun &amp; overall sky color.</li>
<li><code>atmosunlightscale &lt;value&gt;</code> Sets the ratio of the sunlight brightness vs atmo.</li>
</ul>
<h2><a class="anchor" id="autotoc_md87"></a>
2.5 World Level Format</h2>
<p >Because of the Libprimis engine's recursive octree geometry format, it is not practical to save levels in a standardized polygon soup format like GLTF. Instead, Libprimis saves levels in its own format, the general details of which are explained in this section.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
2.5.1 Map Format Summary</h3>
<p >The file is a gz-compressed stream of data, with the following main components:</p>
<ul>
<li>A map header with the sizes of the non-geometry part of the data</li>
<li>A list of map-specific variables, such as enviornment settings</li>
<li>A list of entities with their associated information</li>
<li>A list of virtual texture slots "vslots" which map surfaces to texture indices</li>
<li>An octal tree of cube nodes which make up the level's geometry.</li>
</ul>
<h3><a class="anchor" id="autotoc_md89"></a>
2.5.2 Map Header</h3>
<p >The header tells the engine how many of particular quantities show up in the body of the map file. The header is of fixed length and encodes the following information:</p>
<ul>
<li>an identifier of four chars</li>
<li>the version of the map</li>
<li>the size of the header itself</li>
<li>the size of the level in powers of two</li>
<li>the number of entities saved on the level</li>
<li>the number of PVS saved on the level (not used by the engine)</li>
<li>the number of blendmaps saved on the level (not used by the engine)</li>
<li>the number of variables saved on the level</li>
<li>the number of virtual texture slots (vslots) saved on the level</li>
</ul>
<p >The number of octree nodes, the actual geometry count on the level, is not saved to the map header. This is practical because the octree nodes are the last part of the level file (and so nothing needs to have its location indexed beyond it), and because the octree nodes themselves are recursively loaded due to the octal tree structure of how they are related to each other.</p>
<h3><a class="anchor" id="autotoc_md90"></a>
2.5.3 Map Variables</h3>
<p >The map saves a list of the variables which are to be modified away from the engine defaults. As the engine defaults may change over time, only variables explicitly defined as different in the level get saved here and as a result undefined variables may lead to inconsistent behavior with different versions of the engine.</p>
<p >These variables all have a single float, string, or integer value associated with them and can encode one feature of the level, such as cloud information, skybox settings, or ambient settings.</p>
<p >There is a technical limit of 65636 changed variables for a map due to the size of the data type (ushort) used to index variables, but this is far in excess of the number of variables that the engine has in total.</p>
<h3><a class="anchor" id="autotoc_md91"></a>
2.5.4 Map Entities</h3>
<p >The static map entities (such as lights, spawns, etc.) have their location saved to the level as well as the values of the five attributes which can modify them. Only static entities, like those placed by a mapper, are saved here.</p>
<p >There is a limit of ten thousand entities maximum that are allowed to be saved to the level via the <code>MAXENTS</code> macro. This limit of 10,000 is somewhat arbitrary and not especially technical, but in no realistic circumstance should this be an actual limit for reasonably usable maps in the engine (other engines are likely better for these types of applications).</p>
<p >The architectural limit for the number of map entities is 65636, the same as for map variables, but hitting this limit would require redesign of other parts of the engine to more efficiently process gigantic numbers of entities.</p>
<p >Very large numbers of entities run into performance problems before these technical barriers are hit, as the engine is not designed for especially large entitiy counts. Typical numbers of map entities on maps range from several dozen to several hundred, and the maximum limit imposed, either by the <code>MAXENTS</code> macro or the architectural limit, is far in excess of reasonable level making in this engine.</p>
<h3><a class="anchor" id="autotoc_md92"></a>
2.5.5 Map Vslots</h3>
<p >Following the two (relatively straightforward) lists of variables is the virtual texture slot (vslot) list. This list defines a set of indices which are the values given to the individual cube faces. These indices are much smaller than the actual texture and shader information that they represent, compacting the amount of data required for each cube object to hold. There is on the order of ten thousand to a million cubes on a typical level, making it much more terse to map them by a list of slot indices.</p>
<p >The indices defined in the level do not map to texture information in the map's zipped file: it is instead defined in the associated configuration file which is usually provided along with the map file. This configuration file runs a script which tells the engines which texture &amp; shader information to allocate to a particular slot; this is not filed by the map binary itself.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
3. Entities</h1>
<h2><a class="anchor" id="autotoc_md94"></a>
3.1 Static Entities</h2>
<p >The static entities are world elements which get saved to the level and are loaded on game start. These entities have the following types:</p>
<ul>
<li>light: a point light source</li>
<li>mapmodel: a contained piece of geometry</li>
<li>playerstart: a location where players spawn from</li>
<li>particles: a location where the engine generates dynamic particles</li>
<li>sound: a point sound source</li>
<li>spotlight: a linkable modifier for light entities</li>
<li>decal: texture application onto a geometry face</li>
<li>teleport: a location that moves the player to a teledest</li>
<li>teledest: the output location of a teleporter</li>
<li>jumppad: object that pushes actors around</li>
<li>flag: flag for capture-the-flag gameplay</li>
</ul>
<p >Entities themselves are point objects which can be placed at any arbitrary location within the level. Their effects generally extend to a radius beyond just the point that the occupy, including defined radii for entities like lights or sounds or simply having a defined structure as mapmodels do. Entities are always themselves static on the level and do not move unless manipulated by an editor; however they can have dynamic effects which may make them appear to move.</p>
<p >Entities in Libprimis all have five attributes each, though not all attributes are necessarily defined for a given model. The consistency of ent attributes is designed to make user interface design as straightforward as possible such that complex dynamic methods for menus are not necessary to edit entities.</p>
<p >There is no practical limit to the quantity of entities a level can have; for many common types of entities, performance concerns make any physical limit moot. There exists issues with very excessive numbers of lights overfilling the light buffer or very excessive numbers of sounds causing sound issues, but these are not a concern until the level is already unplayable.</p>
<h3><a class="anchor" id="autotoc_md95"></a>
3.1.1 Lights</h3>
<p >Lights are entities where light appears to eminate from. Lights are point entities and the light they cast is as from a perfect point source. Because the engine is deferred and dynamically lit, light counts are one of the largest influencers of performance, and the engine automatically occludes lights by a tile-based algorithm to not render those lights which do not contribute to the scene. Light entities' performance is highly related to its radius, and therefore use of large light entities for bulk lighting is not recommended and use of sunlight and global illumination is recommended in its place.</p>
<p >Light entities do not benefit from the enhancements that screenspace ambient occlusion and global illumination have on the sunlight, as these features are too expensive to enable on a light-by-light basis. For similar reasons, only point lights are supported, as it is in fact <em>very difficult</em> to create lights with configurations more complex than ideal point radiators.</p>
<p >As lights are one of the key cogs of the deferred renderer used in Libprimis, a more technical discussion of their behavior with respect to the rendering pipeline can be found in that section.</p>
<h4><a class="anchor" id="autotoc_md96"></a>
Attributes</h4>
<p >Lights have five attributes, the last of which itself has a set of flags which control the light's technical behavior.</p>
<h5>0: `radius`</h5>
<p >The maximum distance the light entity can cast light; strongly related to performance impact of the light and shadow map usage</p>
<p >The radius of the light is, as with other distances, defined in cubits.</p>
<h5>1: `red`</h5>
<p >The intensity of the red channel of the light's output. Nominally, 255 is "full" red, but this can be exceeded for an overbright light.</p>
<h5>2: `green`</h5>
<p >The intensity of the green channel of the light's output. Nominally, 255 is "full" green, but this can be exceeded for an overbright light.</p>
<h5>3: `blue`</h5>
<p >The intensity of the blue channel of the light's output. Nominally, 255 is "full" blue, but this can be exceeded for an overbright light.</p>
<h5>4: `flags`</h5>
<p >Lights support four flags which can be combined to achieve particular effects.</p>
<ul>
<li>1 <code>noshadow</code>: treats geometry/models as transparent, allowing light through</li>
<li>2 <code>static</code>: disables shadow map updates, causing static shadows</li>
<li>4 <code>volumetric</code>: simulates light reflection off of dust in the air</li>
<li>8 <code>nospec</code>: disables specular highlights</li>
</ul>
<h3><a class="anchor" id="autotoc_md97"></a>
3.1.2 Mapmodels</h3>
<p >Mapmodels are entities which represent a 3D model. While this object can be animated (e.g. a fan or reciprocating device) it cannot undergo reactive or scripted behavior and the entity itself remains at one point at all times.</p>
<p >Mapmodels are usually supplied in the md3 (Quake III), obj (Wavefront), or iqm (Inter-Quake Model) formats; they additionally need one or more u,v maps (UV maps) to define their surface normals, speculars, and specularity. Unlike level geometry, mapmodels do not support parallax mapping.</p>
<p >Mapmodels in Libprimis have support for hitboxes which closely mirror that of the physical model; however, mapmodels do not support decals and as a result weapons hitting mapmodels do not leave bullet marks like ordinary geometry does.</p>
<h4><a class="anchor" id="autotoc_md98"></a>
Attributes</h4>
<p >Mapmodels have controllable attributes for their size and orientation; the particular mapmodel to be used is given by an index. Note that the possession of only three degrees of freedom means that the model can become gimbal locked if orientation values are chosen poorly.</p>
<h5>0: `index`</h5>
<p >Selects the index of the passed models which are loaded into the map to display. As usual, this index begins at 0 and counts upwards; the engine will simply display nothing if there is no valid model at the index.</p>
<p >Mapmodels are generally defined in map configuration files and therefore the specific model assigned to each index is not enforced game-wide.</p>
<h5>1: `yaw`</h5>
<p >The yaw (azimuthal) angle of the model, in left-handed (clockwise) degrees. Values larger than 360 can be passed but are identical to passing in their modulus 360.</p>
<h5>2: `pitch`</h5>
<p >The pitch (altitude) angle of the model, expressed as an inclination from the horizon. Negative values can be used to pitch the model towards the -z axis.</p>
<h5>3: `roll`</h5>
<p >The roll angle of the model, expressed as a right-handed rotation about the axis set by the <code>pitch</code>/<code>roll</code> attributes.</p>
<h5>4: `scale`</h5>
<p >The scale factor of the model. Scaling is always isotropic (no distortion) and the identity point is at 100 (100 is "normal" scale) as opposed to 1 for many other engine features; this is because the arguments passed to entities are always integers (and obviously setting 1 as unity w/ only integral steps would be not quite optimal).</p>
<h3><a class="anchor" id="autotoc_md99"></a>
3.1.3 Playerstarts</h3>
<p >The playerstarts define where players respawn after they are killed. Unsurprisingly, playerstarts have a team associated with them which determines the group of players who are allowed to spawn there; team spawns only can spawn the players belonging to that team.</p>
<p >Playerstarts have attributes which define the orientation of players who spawn at them. The playerstart entity has only two relevant attributes; the last three attributes have no effect on the behavior of the entity.</p>
<h4><a class="anchor" id="autotoc_md100"></a>
Attributes</h4>
<h5>0: `team`</h5>
<p >0 for FFA, 1/2 for teams blue and red respectively. Available spawns for any arbitrary player are limited to playerstarts who share the same team index.</p>
<h5>1: `yaw`</h5>
<p >The yaw (azimuthal) angle of the player when they spawn, in left-handed (clockwise) degrees. Setting the yaw of the playerstart is important to prevent players from spawning facing the wrong way, such as towards a wall.</p>
<h3><a class="anchor" id="autotoc_md101"></a>
3.1.4 Particles</h3>
<p >The six types of implemented particles use their five attributes differently. As a result, this section is has its last four attributes' descriptions seperated into sections by the type of particle in use (which is set by parameter 0 <code>type</code>).</p>
<p >Particles do not collide with players or are dynamically manipulated by physics; they are, however, culled upon collision with cube geometry to minimize wasteful rendering of particles which cannot be seen.</p>
<p >Particles are billboards, meaning that they are 2d objects which always have their normal vector pointed at the camera. For this reason, particles' orientation is determined by the camera, not the scene, and for objects that are usually anisotropic (like fire, which only makes sense in one direction), this approximation can yield some poor results. For this reason, maximum particle size is generally kept fairly small to prevent the obviousness of billboarding.</p>
<p >Additionally, particles are client side effects, meaning that one person's view of a particle is not representative of the effect rendered on other people's machines.</p>
<h4><a class="anchor" id="autotoc_md102"></a>
Attributes</h4>
<p >Easily the most complex entity with respect to its attributes, particles have unique specifications for each value passed to its first attribute <code>type</code>. This means that particles cannot have their <code>type</code> changed and have attributes consistently transfer.</p>
<h5>0: `type`</h5>
<p >The type of particle for the game to render. There are six types implemented:</p>
<ul>
<li>0 fire</li>
<li>1 smoke</li>
<li>2 water</li>
<li>3 plasma</li>
<li>4 tape</li>
<li>5 status</li>
</ul>
<p >Fire particles create a vertical plume of fire, with customizable footprint, particle size/total height, and color. Fire particles also have nonoptional smoke which appears at the top of the plume.</p>
<p >Smoke particles create a slightly directional gray cloud of smoke, with a direction selectable along six directions (the three coordinate axis directions and their negatives). Smoke cannot have its color changed, and is always a moderate shade of gray.</p>
<p >Water particles create a small fountain effect which can, like smoke, have its direction selectable from the aformentioned six directions. Water can have its color changed to suit the liquid being represented, but the physics of the particle movement are fixed except for their orientation.</p>
<p >Plasma particles are a large, brightly colored ball of gas which hovers about the entity point. Unlike other particles, plasma does not spawn in multitudes and then fade; it remains a hovering entity at all times, with its only variation being a pulsing effect.</p>
<p >Tape particles are a raylike particle type that creates light beams along a specified direction. While they are restricted to the same six directions as water and smoke, there is a large variety of modes which they can occupy for each direction, including plane, sphere, cone, circle, and ray configurations.</p>
<p >Status particles display a billboard displaying a bar which can be configured to be filled between 1 and 100. Through scripting, it is possible to dynamically change this value (by manually editing the entity attributes e.g.) to make it dynamically display some desired gameplay aspect. Status particles can have their bar color set, but the background and outline colors are fixed.</p>
<p >Each of these has different attributes 1-4 and obviously shows the particle type aformentioned.</p>
<h5>1: `radius` (fire, plasma); `dir` (smoke, water, tape); `fill` (status)</h5>
<p >For fire and plasma, the radius paramater controls how large the particle can be. For fire, this is the areal size; the size that the "base" of the flame occupies. This area is always a perfect square (meaning many entities are required for a potential rectangular shape).</p>
<p >Likewise, for plasma, this parameter controls the radius of the sphere bounded by the plasma effect.</p>
<p >For smoke, water, and tape, this parameter defines the orientation of the particle. Only tape takes into account values above 5 or the directionality of the particle; water and smoke are restricted to "ray" type configurations only.</p>
<p >The lowest valid index for each particle configuration is listed in the table below:</p>
<ul>
<li>The value is the number put in the <code>type</code> attribute of the entity.</li>
<li>The type is the geometrical shape of the configuration.</li>
<li>The orientation describes the way the whole configuration points.</li>
<li>The direction is the orientation of individual rays relative to the origin.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Orientation   </th><th class="markdownTableHeadNone">Direction    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Ray   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Ray   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Ray   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Ray   </td><td class="markdownTableBodyNone">-z   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Ray   </td><td class="markdownTableBodyNone">-x   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Ray   </td><td class="markdownTableBodyNone">-y   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">256   </td><td class="markdownTableBodyNone">Circle   </td><td class="markdownTableBodyNone">xy plane   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">257   </td><td class="markdownTableBodyNone">Circle   </td><td class="markdownTableBodyNone">yz plane   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">258   </td><td class="markdownTableBodyNone">Circle   </td><td class="markdownTableBodyNone">xz plane   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">259   </td><td class="markdownTableBodyNone">Ring   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">260   </td><td class="markdownTableBodyNone">Ring   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">261   </td><td class="markdownTableBodyNone">Ring   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">262   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">263   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">264   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">265   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">-z   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">266   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">-x   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">267   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">-y   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">268   </td><td class="markdownTableBodyNone">Plane   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">269   </td><td class="markdownTableBodyNone">Plane   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">270   </td><td class="markdownTableBodyNone">Plane   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">271   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xz (+z)   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">272   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xy (+x)   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">273   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">yz (+y)   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">274   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">yz (+z)   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">275   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xz (+x)   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">276   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xy (+y)   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">277   </td><td class="markdownTableBodyNone">Sphere   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">278   </td><td class="markdownTableBodyNone">Sphere   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">279   </td><td class="markdownTableBodyNone">Sphere   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Away    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">288   </td><td class="markdownTableBodyNone">Circle   </td><td class="markdownTableBodyNone">xy plane   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">289   </td><td class="markdownTableBodyNone">Circle   </td><td class="markdownTableBodyNone">yz plane   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">290   </td><td class="markdownTableBodyNone">Circle   </td><td class="markdownTableBodyNone">xz plane   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">291   </td><td class="markdownTableBodyNone">Ring   </td><td class="markdownTableBodyNone">-z   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">292   </td><td class="markdownTableBodyNone">Ring   </td><td class="markdownTableBodyNone">-x   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">293   </td><td class="markdownTableBodyNone">Ring   </td><td class="markdownTableBodyNone">-y   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">294   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">295   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">296   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">297   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">-z   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">298   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">-x   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">299   </td><td class="markdownTableBodyNone">Cone   </td><td class="markdownTableBodyNone">-y   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">300   </td><td class="markdownTableBodyNone">Plane   </td><td class="markdownTableBodyNone">-z   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">301   </td><td class="markdownTableBodyNone">Plane   </td><td class="markdownTableBodyNone">-x   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">302   </td><td class="markdownTableBodyNone">Plane   </td><td class="markdownTableBodyNone">-y   </td><td class="markdownTableBodyNone">Normal    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">303   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xz (+z)   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">304   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xy (+x)   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">305   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">yz (+y)   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">306   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">yz (+z)   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">307   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xz (+x)   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">308   </td><td class="markdownTableBodyNone">Line   </td><td class="markdownTableBodyNone">xy (+y)   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">309   </td><td class="markdownTableBodyNone">Sphere   </td><td class="markdownTableBodyNone">+z   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">310   </td><td class="markdownTableBodyNone">Sphere   </td><td class="markdownTableBodyNone">+x   </td><td class="markdownTableBodyNone">Towards    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">311   </td><td class="markdownTableBodyNone">Sphere   </td><td class="markdownTableBodyNone">+y   </td><td class="markdownTableBodyNone">Towards   </td></tr>
</table>
<p >For a status particle, this parameter defines the particle's fullness, as a range between 0 and 100. At 100, the bar is full; values above this have no additional effect.</p>
<h5>2: `color` (water, plasma, status); `size` (tape, fire); `null` (smoke)</h5>
<p >For water, plasma, and status entities, parameter 2 specifies the particle's color. This is passed as a hexadecimal triple (<code>0x000</code>...<code>0xFFF</code>) which specifies the color of the particle to four-bit precision. While four bits per channel is indeed very low compared to common pictographic formats (typically 256 colors per channel), in practice particles (which are essentially monochromatic) do not need a gigantic amount of distinct colors (there is essentially no difference between 0xF00 and 0xE00 that matters when picking a slab of color).</p>
<p >For tape particles, this parameter specifies the length of each tape particle. This does not meaningfully affect the width of the tape particles, only its length, and so the only way to reduce the apparent thickness is instead by its <code>color</code> parameter.</p>
<p >For fire particles, this parameter defines the height and size of the fire particles. Larger fire particles last proportionally longer (and this ratio is fixed) and therefore rise to a greater height before fading.</p>
<p >This parameter has no effect on smoke particles and any value specified will be ignored.</p>
<h5>3: `color` (tape, fire); `null` (smoke, plasma, water, status)</h5>
<p >Tape has its color parameter on the third attribute, and it works in the same hexadecimal triple form as the above explaination of color for the other particle types. In the same way, the color of the fire particles' flames can be set. The smoke that fire particles release cannot be modified.</p>
<p >None of the other entities take this attribute into account and setting a value for any of them will be ignored.</p>
<h5>4: `null` (fire, plasma, smoke, status, water); `fade` (tape)</h5>
<p >Only tape particles take this parameter into account; fade sets the time in milliseconds for the particle to delete itself once it has been spawned. Tape particles fade out gradually and do not get jarringly deleted at the specified time. Note that the fade out rate is a fixed ratio of the total particle lifetime and therefore quicker when the tape particle is set to die out relatively quickly.</p>
<p >For all other particle types, this parameter can be set to any value but will be ignored.</p>
<h3><a class="anchor" id="autotoc_md103"></a>
3.1.5 Sound</h3>
<p >Sound entities place a static, looping sound effect at the point where the entity is placed. Sound entities can only have their volume modulated globally and by radius. Sound entities take a sound index which defines the entry in the engine's mapsound list which is played; this is generally set in the map's configuration file which is executed at map start. This sound entity is then triggered upon a player entering its characteristic radius, playing the set sound (locally) at them. Sounds are not ensured to sync perfectly across different clients.</p>
<p >Sound playback from entities does take into account location of the entity and therefore plays back the sound in stereo, with the sound intensity per channel defined by the location of the entity.</p>
<h4><a class="anchor" id="autotoc_md104"></a>
Attributes</h4>
<p >There are two attributes for the sound entity, the index of the sound and radius at which it starts playing.</p>
<h5>0: `index`</h5>
<p >The index of the sound entity indicates to the engine which of the set sounds declared in the map configuration file is to be played by the entity. This index counts up from zero (negative values never index a valid sound) and values beyond the number of indexed sounds simply fail silently (heh) and no sound effect is played.</p>
<h5>1: `radius`</h5>
<p >The radius within which the game will play the index-defined sound at the player. This radius, as always, is in cube units of 1/8m, and the bounding surface for sound entities is always a simple sphere, represented in edit mode by a wireframe bounding indicator. At distances beyond this radius, sound playback from the entity is automatically rejected and the sound entity does not playback in any form.</p>
<h3><a class="anchor" id="autotoc_md105"></a>
3.1.6 Spotlights</h3>
<p >Spotlight entities require linking to standard entities, such as by <code>entlink</code>. Once attached to a light, the spotlight acts as a modifier to the light entity, creating a directed cone of light. The spotlight's lone attribute controls the spread of the cone, and the vector from the light entity to the spotlight sets the axis which the spotlight is oriented along. The location of the spotlight otherwise has no effect upon the behavior of the spotlight's cast beam.</p>
<p >Notably, spotlights cause the light entity in question to switch from cubemapping to planar mapping, resulting in issues when surfaces are normal to the plane of the mapping (which is tangent to the point of the cone and normal to the axial vector); since the mapping has no detail along the normal direction, there exists aliasing issues along that face, and as a result large cone sizes which project onto faces parallel with the spotlight vector is not recommended.</p>
<h4><a class="anchor" id="autotoc_md106"></a>
Attributes</h4>
<p >The lone attribute for the spotlight entity determines the spread of the cone of light. An implicit attribute, the position of the entity, sets the direction of the beam (measured relative to the location of the linked light.</p>
<h5>0: `angle`</h5>
<p >This attribute sets the spread of the cone of light set by the spotlight entity. The overall inside angle of the cone is equal to twice the value of this attribute; the attribute measures the angle between the edge and center of the beam. This attribute is capped at 90 degrees: as a result of single-plane mapping, "spotlights" with a cone of light beyond 180 degrees is not representable with the projection.</p>
<h3><a class="anchor" id="autotoc_md107"></a>
3.1.7 Decals</h3>
<p >Decals are static entities which act to project an image (specified by an index) onto a surface of cube geometry. The limitation to cube geometry is an important one, one that precludes the usage of mapmodels that can be manipulated easily within the engine. Stains, which are used by weapons, can place their images upon any type of geometry, including mapmodels.</p>
<p >Decals are loaded into the map's configuration file in the same manner that textures are. The order in which the decals are defined sets their map-specific index, which is then referenced when specifying the image used by the decal entity.</p>
<h4><a class="anchor" id="autotoc_md108"></a>
Attributes</h4>
<p >Decal entities have all five attributes contribute to the entity's behavior: the first is the decal index, declared in the map configuration, while the last four determine the orientation (1,2,3) and scale (4) of the decal. This is the same set and order of attributes used for the <code>mapmodel</code> entity.</p>
<h5>0: `index`</h5>
<p >Selects the index determining which of the decals that are loaded into the map are to be displayed. As usual, this index begins at 0 and counts upwards; the engine will simply display nothing if there is no valid decal at the index.</p>
<p >Decals are generally defined in map configuration files and therefore the specific decal assigned to each index is not enforced game-wide. The decal's index is simply allocated by the position of the decal's reference relative to other decal references (the first mapmodel declared in the configuration file is indexed 0, the second one 1, etc.).</p>
<h5>1: `yaw`</h5>
<p >The yaw (azimuthal) angle of the decal, in left-handed (clockwise) degrees. Values larger than 360 can be passed but are identical to passing in their modulus 360.</p>
<h5>2: `pitch`</h5>
<p >The pitch (altitude) angle of the decal, expressed as an inclination from the horizon. Negative values can be used to pitch the decal towards the -z axis.</p>
<h5>3: `roll`</h5>
<p >The roll angle of the decal, expressed as a right-handed rotation about the axis set by the <code>pitch</code>/<code>roll</code> attributes.</p>
<h5>4: `scale`</h5>
<p >The scale factor of the decal. Scaling is always isotropic (no distortion) and the identity point is at 100 (100 is "normal" scale) as opposed to 1 for many other engine features; this is because the arguments passed to entities are always integers (and obviously setting 1 as unity w/ only integral steps would be not quite optimal).</p>
<h2><a class="anchor" id="autotoc_md109"></a>
3.2 Projectiles</h2>
<p >Unlike static entities, projectiles are not created directly by mappers and are instead created primarily by weapons as their fired projectiles. Projectiles are synced across the server (as befitting their usually deadly nature) and carry a number of properties befitting this which are distinct from static entities.</p>
<h3><a class="anchor" id="autotoc_md110"></a>
3.2.1 Projectile Attribute Overview</h3>
<p >Projectiles have eleven attributes encoded within them which define their entire behavior from birth to death. Projectiles are created when a weapon fires, and as a result they have owners and attack data.</p>
<ul>
<li>vec <code>dir</code> direction that the projectile is pointed</li>
<li>vec <code>o</code> location of the projectile currently</li>
<li>vec <code>from</code> world coordinates where the projectile starts</li>
<li>vec <code>to</code> world coordiantes where the projectile ends</li>
<li>vec <code>offset</code> displacement from from/to vec path defined</li>
<li>float <code>speed</code> speed of projectile in cubits/s</li>
<li>gameent <code>*owner</code> player who created the projectile</li>
<li>int <code>atk</code> attack type of the projectile</li>
<li>bool <code>local</code> multiplayer sync flag for the projectile</li>
<li>int <code>offsetmillis</code> time delay for the projectile</li>
<li>int <code>id</code> unique identifier for the projectile</li>
</ul>
<h3><a class="anchor" id="autotoc_md111"></a>
3.2.2 Projectile Vector Attributes</h3>
<p >There are five vector attributes which describe the orientation and velocity of the projectile. These are the <code>dir</code>ection, l<code>o</code>cation, <code>from</code> originating position, <code>to</code> destination position, and <code>offset</code> displacement from path.</p>
<h4><a class="anchor" id="autotoc_md112"></a>
`dir`ection</h4>
<p >The first attribute of these is the <code>dir</code>ection, which determines the orientation of the projectile. This vector determines the orientation of the projectile in space, and is set to point along the direction of the target (parallel to the velocity). As this vector does not imply a magnitude, it should be a normalized (magnitude of 1) vector. This vector is in world coordinates, as there is no independent coordinate system for projectiles defined by their movement. As a result, corrections to a projectile entity must come from manual changes to the direction of this parameter.</p>
<p >As this attribute is a 3 dimensional vector, there is no way of controlling the roll of the projectile. As a result, spiraling projectiles are not possible.</p>
<h4><a class="anchor" id="autotoc_md113"></a>
l`o`cation</h4>
<p >The second attribute is the l<code>o</code>cation of the projectile currently. At t=0 this parameter is set to be the same as the <code>from</code> parameter, and the l<code>o</code>cation at later times evolves towards the <code>to</code> location with respect to time. This vector is expressed in the world coordinate system, which is the same for every projectile.</p>
<h4><a class="anchor" id="autotoc_md114"></a>
`from`</h4>
<p >The third attribute is the place where the vector is <code>from</code>. This is, for a weapon-generated projectile, the location that the gun is when the projectile is created. This vector is also identical to the l<code>o</code>cation vector at the time when the projectile is created.</p>
<p >As with the l<code>o</code>cation vector, this vector is expressed in terms of world coordinates, and all projectiles share the same coordinate system.</p>
<h4><a class="anchor" id="autotoc_md115"></a>
`to`</h4>
<p >The point on the map where the projectile is pointed towards. This is, for a weapon-generated projectile, the location at a distance given in the <code>range</code> parameter; this point may be inside geometry, in which case the collision checker will destroy the projectile at that point.</p>
<h4><a class="anchor" id="autotoc_md116"></a>
`offset`</h4>
<p >The <code>offset</code> vector determines the location the projectile appears to originate, as a distance away from the actual start position. This is used to make the projectile appear from the gun rather than from the player's coordinate, and as a result this attribute, unsurprisingly, is a displacement rather than a position vector.</p>
<h3><a class="anchor" id="autotoc_md117"></a>
3.2.3 Other Projectile Attributes</h3>
<p >The non-vector attributes that projectiles posess include the projectile's speed (which does contribute to the not-explicitly-defined velocity vector), the owner of the projectile, the attack type of the projectile, the locality flag, the delay time for</p>
<h4><a class="anchor" id="autotoc_md118"></a>
`speed`</h4>
<p >The <code>speed</code> of the projectile is the rate, in cubits, that the projectile moves through the world. This, along with the direction determined by the difference of the <code>to</code> and <code>from</code> vectors, defines the projectile's velocity vector.</p>
<h4><a class="anchor" id="autotoc_md119"></a>
`owner`</h4>
<p >The pointer to the <code>gameent</code> object that the projectile is credited to. Projectiles are created by players, so to track accuracy and kills, projectiles are always associated with a player object.</p>
<h4><a class="anchor" id="autotoc_md120"></a>
`atk`</h4>
<p >The index for the attack type the projectile embodies. This attack type corresponds to a particular weapon's attack, and therefore serves as a proxy for the properties that particular weapon attacks have, such as the projectile's visible type, size, and damage. As a result, this value can only correspond to defined weapon attack types and encodes specific, specified sets of values.</p>
<h4><a class="anchor" id="autotoc_md121"></a>
`local`</h4>
<p >This attribute flags the projectile as being local. Projectiles created by the player will have this flag set as true, and projectiles that are created as representations of other client's projectiles will have this set to false. This flag affects whether the game uses this projectile's location to determine hits (as other client's projectiles are not necessarily synced with the root client's machine, the game relies on those other clients to hit check their own projectiles. While this has some issues with abuse, this does mean that players who see their bullets hit a target will always be credited with those hits, even if other clients did not see the bullet hit them.</p>
<h4><a class="anchor" id="autotoc_md122"></a>
`offsetmillis`</h4>
<p >As the name indicates, this attribute sets the offset time for the projectile to start moving. This attribute is expressed in milliseconds, and needs to always be positive to have any meaning.</p>
<h4><a class="anchor" id="autotoc_md123"></a>
`id`</h4>
<p >Each projectile is given a unique tracking id by the engine, which is set by the time at which the projectile spawns. This is the handle by which the projectile can later be identified (such as to find its owner).</p>
<h3><a class="anchor" id="autotoc_md124"></a>
3.2.4 Projectile Time Evolution</h3>
<p >Projectiles in the engine have simple kinematics, as neither gravity nor drag act upon them. As such, projectiles move in straight lines at constant speed, and do not drop or slow down over the course of their travel. This movement continues until the projectile reaches its <code>to</code> point defined in the object or collides with something, after which point it is destroyed.</p>
<p >Every physics frame, the projectiles owned by the player's own client are checked for collision with players before being checked against the world geometry. Those projectiles that collide with players are then eligible to deal damage; projectiles that collide with world geometry are discarded after potentially throwing decals onto nearby surfaces (like burn marks or bullet holes).</p>
<p >As projectile speeds are defined in cubits per second, multiplication by 8 yields a speed in meters per second. As a result, for reference, the speed of sound at standard temperature and pressure (343 m/s) is equivalent to about 2750 cubits/s.</p>
<p >Since the trajectory of the projectile is parameterized in terms of its end location and its speed, the maximum time in flight must be calculated by the range by the speed.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
3.3 Bouncers</h2>
<p >Bouncers are entirely unrelated to jumppad entities and are the name given to the particles which can bounce off of surfaces. Bouncers do not interfere with players in any way, and are capable of bouncing off of geometry for an arbitrary number of times before being deleted and replaced with a decal.</p>
<p >Bouncers have two implemented types, gibs (bits of dead players) and debris, and are defined by a set of twelve unique parameters as well as being a child of the general <code>physent</code> class of game objects.</p>
<p >Unlike projectiles, which are parameterized in terms of maximum range, bouncers are parameterized in terms of their lifetime. Note that while vectors like start position are not listed below, they do exist as part of the parent physent class.</p>
<p >The twelve unique parameters that bouncers have are as follows:</p>
<ul>
<li>int <code>lifetime</code> time left until the bouncer dies</li>
<li>int <code>bounces</code> number of bounces that have been done</li>
<li>float <code>lastyaw</code> yaw of the projectile at the last timestep</li>
<li>float <code>roll</code> roll of the projectile at the last timestep</li>
<li>bool <code>local</code> multiplayer sync flag for the projectile</li>
<li>gameent <code>*owner</code> gameent which the projectile belongs to</li>
<li>int <code>bouncetype</code> type of bounce the bouncer does</li>
<li>int <code>variant</code> random variant of bouncer that this bouncer has</li>
<li>vec <code>offset</code> world offset, starts at bouncer spawn point</li>
<li>int <code>offsetmillis</code> time of projectile creation</li>
<li>int <code>id</code> unique id assigned to each bouncer entity</li>
</ul>
<h2><a class="anchor" id="autotoc_md126"></a>
3.4 Stains</h2>
<p >Stains are a type of decal that is generally applied by the effect of another entity's death. Examples of this include the bullet holes left behind when a projectile makes contact with a surface or the blood stains left behind by a dead actor's giblet.</p>
<h3><a class="anchor" id="autotoc_md127"></a>
3.4.1 Stain Objects</h3>
<p >Stain objects have the following properties in their individual objects:</p>
<ul>
<li>int <code>millis</code> The game time when the stain spawns</li>
<li>bvec <code>color</code> The color of the stain texture</li>
<li>uchar <code>owner</code> The stain buffer the stain belongs to</li>
<li>ushort <code>startvert</code> The vertex in the buffer the stain starts at</li>
<li>ushort <code>endvert</code> The vertex in the buffer the stain ends at</li>
</ul>
<h3><a class="anchor" id="autotoc_md128"></a>
3.4.2 Stain Settings</h3>
<p >Unlike typical particles and decals, stains, by virtue of their entirely cosmetic nature, have user-configurable settings to control their impact on visuals and performance. For this reason, stains should never be assumed as they can be turned off or modified client-side.</p>
<p >The commands:</p>
<ul>
<li><code>stainfade &lt;value&gt;</code> time in s before stains fade away</li>
<li><code>stains &lt;bool&gt;</code> toggles rendering of stains</li>
<li><code>dbgstain &lt;bool&gt;</code> toggles debug output for stains</li>
</ul>
<p >There are some Cubescript aliases which relate to shaders; those are not user commands and are not covered here.</p>
<h2><a class="anchor" id="autotoc_md129"></a>
3.5 Particles</h2>
<p >Particles are billboarded objects which are rendered clientside and simulate small objects of various types. Particles broadly have three types: traditional pointlike particles, linear "tape"-like particles, and meters.</p>
<p >As billboards, particles always face towards the player and therefore are always viewed face-on. As a result, particle rendering is unique to each player and is not shared across the server (as a point will have different facing vectors to different actors' cameras.</p>
<p >Particles are not physents and do not bounce off of geometry nor interact with the world in any particular way. Particles do, however, cull themselves upon contact with geometry to prevent excessive resource usage.</p>
<h3><a class="anchor" id="autotoc_md130"></a>
3.5.1 Particle Types</h3>
<p >Particles have many specific types which behave in different ways.</p>
<ul>
<li><code>part</code> a point-like particle, such as puffs of smoke or flames</li>
<li><code>tape</code> an unanimated line particle that extends between two points</li>
<li><code>trail</code></li>
<li><code>text</code> a text billboard, such as a player's name</li>
<li><code>textup</code></li>
<li><code>meter</code> a meter with a fill between 0 and 100</li>
<li><code>metervs</code></li>
<li><code>fireball</code> an animated fireball</li>
</ul>
<h3><a class="anchor" id="autotoc_md131"></a>
3.5.2 Particle Properties</h3>
<ul>
<li>vec <code>o</code> origin vector triple</li>
<li>vec <code>d</code> direction vector triple</li>
<li>int <code>gravity</code> gravity scale (&lt;0 for upwards floaters)</li>
<li>int <code>fade</code> fade scale</li>
<li>int <code>millis</code> time in ms before fade</li>
<li>bvec <code>color</code> color vector triple</li>
<li>uchar <code>flags</code> particle-specific flags</li>
<li>float <code>size</code> radius of particle</li>
<li>union <code>(char *text, float val, physent *owner, (uchar color2[3], progress)</code></li>
</ul>
<p >The union type can be any of the objects listed inside the union. However, it can only be one object at once. The union structure is outlined below:</p>
<div class="fragment"><div class="line">                              union</div>
<div class="line"> </div>
<div class="line">0                                                             63 bit</div>
<div class="line">+--------------------------------------------------------------+</div>
<div class="line">|                            *text                             |</div>
<div class="line">+--------------------------------------------------------------+</div>
<div class="line">                               OR</div>
<div class="line">0                              31                             63 bit</div>
<div class="line">+-------------------------------+------------------------------+</div>
<div class="line">|             val               ||||||||||||||||||||||||||||||||</div>
<div class="line">+-------------------------------+------------------------------+</div>
<div class="line">                               OR</div>
<div class="line">0                                                             63 bit</div>
<div class="line">+--------------------------------------------------------------+</div>
<div class="line">|                            *owner                            |</div>
<div class="line">+--------------------------------------------------------------+</div>
<div class="line">                               OR</div>
<div class="line">0       7      15      23      31                             63 bit</div>
<div class="line">+-------+-------+-------+-------+------------------------------+</div>
<div class="line">|color2 |color2 |color2 |-prog- ||||||||||||||||||||||||||||||||</div>
<div class="line">+-------+-------+-------+-------+------------------------------+</div>
</div><!-- fragment --><p >The union is set as one of the four rows depending on the type of particle present:</p>
<ul>
<li><code>*text</code> pointer for a text entity</li>
<li><code>val</code> float for a fireball</li>
<li><code>*owner</code> pointer for a particle's owner</li>
<li><code>color2[3]</code> array and <code>progress</code> values for a meter</li>
</ul>
<h3><a class="anchor" id="autotoc_md132"></a>
3.5.3 Pointlike Particles</h3>
<p >The pointlike particles are internally refered to as being of the type <code>part</code>; they are the particles that are most accurately refered to as a "particle". Pointlike particles generally are created with some velocity along an axis and additionally have some gravitational term which causes them to move in the z direction.</p>
<p >Particle static entities of type <code>water</code>, <code>fire</code>, <code>smoke</code> are rendered as pointlike particles.</p>
<h3><a class="anchor" id="autotoc_md133"></a>
3.5.4 Tape Particles</h3>
<p >Tape particles are called <code>tape</code> for their resemblance to barricade tape in its stationary, straight appearance, and act to create beam-like effects in the level. The static particle entity which uses tape particles also goes by the name <code>tape</code>; it creates tape particles along a certain direction.</p>
<h3><a class="anchor" id="autotoc_md134"></a>
3.5.5 Trail Particles</h3>
<p >Trail particles create a number of standard particles radiating out from a region of space. The <code>water</code> static particle entity type uses a particle trail. Trail particles are potentially useful for following a projectile.</p>
<h3><a class="anchor" id="autotoc_md135"></a>
3.5.6 Text and Textup Particles</h3>
<p >Text particles are most notably used ingame to render player names above their heads. They also make an appearance while editing entities, as the entity type is rendered as a particle above the entity origin.</p>
<p >Text particles have settable string, color, size and blend options to control the content, transparency, font size, and color of the rendered text. There font size is proportional to the particle's size parameter and does not follow typesetting convention (as these don't make much sense with a 3D engine).</p>
<h3><a class="anchor" id="autotoc_md136"></a>
3.5.7 Meter and Metervs Particles</h3>
<p >Meters are a status particle used to show the size of a particular value passed to its <code>progress</code> value. <code>progress</code> is capped to values up to 100, and as a result meters are restricted to integral percents in their representation.</p>
<p >More resolution is not particularly important for these particles, as they do not display the actual value passed as a value, and those reading a meter particle ingame would have trouble discerning values within a percent.</p>
<h3><a class="anchor" id="autotoc_md137"></a>
3.5.8 Fireball Particles</h3>
<p >Fireballs are animated billboards which appear as a large ball of bright gas. They are round and their general appearance is isotropic (no particular orientation). Fireballs pulsate and have their surface change with time, which makes them particularly suitable for relatively large sizes (normal particles are static and hence fairly boring if they are multiple meters across.)</p>
<p >Fireballs are perhaps the particle least obviously a 2d billboard, as a result its constant animation and scale change.</p>
<h2><a class="anchor" id="autotoc_md138"></a>
3.6 Physics</h2>
<p >Physics apply to game entities called <code>physents</code>. Physents have a large number of properties which affect their time evolution, and additionally are able to realistically collide with surfaces.</p>
<p >Physents include item drops, players, non-player actors, and bouncers. These entities also have additional properties unique to their respective entity types, as they are all seperate children of the physent class.</p>
<h3><a class="anchor" id="autotoc_md139"></a>
3.6.1 Physent Properties</h3>
<p >Physents all have the following properties:</p>
<ul>
<li>vec <code>o</code> origin vector (location displacement vector from origin)</li>
<li>vec <code>vel</code> velocity vector</li>
<li>vec <code>falling</code> gravity vector</li>
<li>vec <code>deltapos</code> position displacement</li>
<li>vec <code>newpos</code> interpolated next position</li>
<li>float <code>yaw</code> yaw angle (around horizon CW)</li>
<li>float <code>pitch</code> pitch angle (up/down; -90 down; 0 horizon; 90 up)</li>
<li>float <code>roll</code> roll angle (CW about yaw+pitch vector)</li>
<li>float <code>maxspeed</code> speed limit for this object (clamp speed to this level)</li>
<li>int <code>timeinair</code> time spent without being on the ground in ms</li>
<li>float <code>radius</code> size of entity</li>
<li>float <code>eyeheight</code> height of eyes (default player = 18(/8) = 2.25m)</li>
<li>float <code>maxheight</code> vertical size of entity (default palyer 18(/8) = 2.25m)</li>
<li>float <code>aboveeye</code> clearance above eyes (default player 2(/8) = .25m)</li>
<li>float <code>xradius</code> x hitbox radius</li>
<li>float <code>yradius</code> y hitbox radius</li>
<li>float <code>zmargin</code> z hitbox margin</li>
<li>vec <code>floor</code> orientation of floor below physent</li>
<li>int <code>inwater</code> material name of liquid that physent is in (0 otherwise)</li>
<li>bool <code>jumping</code> whether the ent is in the process of jumping</li>
<li>char <code>move</code> forwards and reverse movement</li>
<li>char <code>strafe</code> side to side movement</li>
<li>char <code>crouching</code> crouching (players)</li>
<li>uchar <code>physstate</code> type of behavior physent is undergoing (e.g. falling)</li>
<li>uchar <code>state</code> in normal play, state of physent (e.g. alive, spectating)</li>
<li>uchar <code>editstate</code> in edit, state of physent (e.g. alive, spectating)</li>
<li>uchar <code>type</code> type of entity (e.g. player)</li>
<li>uchar <code>collidetype</code> bounding box type (e.g. elliptical)</li>
<li>bool <code>blocked</code> toggles whether the ai should consider the physent blocked</li>
</ul>
<h3><a class="anchor" id="autotoc_md140"></a>
3.6.2 Collision</h3>
<h1><a class="anchor" id="autotoc_md141"></a>
5 Render</h1>
<p >The core of the Libprimis engine is its renderer. The renderer is what transforms the abstract objects in the world into visuals onscreen.</p>
<p >Libprimis' rendering capabilities are essentially a subset of Tesseract's, as many static features in the Tesseract engine are not possible in Libprimis' dynamic use case. The renderer is deferred, as opposed to forward as with engines like Cube 2, and is capable of large numbers of dynamic lights onscreen due to its architecture.</p>
<h2><a class="anchor" id="autotoc_md142"></a>
5.1 Texturing</h2>
<p >Textures on world geometry can have one or several shaders applied to it which affects its appearance. These effects are usually defined per-texture and therefore immutable ingame, and can be modified on a per-map basis.</p>
<h3><a class="anchor" id="autotoc_md143"></a>
5.1.1 Shader Overview</h3>
<h4><a class="anchor" id="autotoc_md144"></a>
Diffuse mapping (`stdworld`)</h4>
<p >This is the standard color image of the texture, and what the texture browser displays in its tiles. All other shaders also implicity present the diffuse map.</p>
<p >It is not possible (nor sensible) to have a texture without diffuse mapping, as it provides the base image upon which other shaders may take effect.</p>
<h4><a class="anchor" id="autotoc_md145"></a>
Normal mapping (`bumpworld`)</h4>
<p >This is mapping the surface normals (the actual orientation of the surfaces) and calculating how the diffuse map's irradiated light changes because of the orientation of the texture (regions pointing away from you are going to have less area to shine light at you).</p>
<p >Normal mapping is a staple of 3D graphics, and nearly all surfaces have some normal direction variance (macroscopic variance). Only where surfaces are homogeneous and smooth (think lacquered surfaces) might it be applicable to forgo a normal map.</p>
<p >Normal maps have three channels, corresponding to the three components of the normal vector at any given point. By packing these three channels into a texture file, it's possible to encode normal vector information for an entire surface.</p>
<h4><a class="anchor" id="autotoc_md146"></a>
Specular highlights (`specworld`)</h4>
<p >This creates a specular reflection (where the surface reflects light sources like a mirror) over the entire surface uniformly. The specular reflection borrows none of its color from the underlying texture, and all of it from the light it originally came from.</p>
<p >Specular highlights are homogeneous and do not take into account the reflectivity of the surface, which is taken to be a defined constant. Most real-world surfaces are not this homogeneous, and require a more complex shader, outlined immediately below.</p>
<h4><a class="anchor" id="autotoc_md147"></a>
Specular mapping (`specmapworld`)</h4>
<p >This maps out certain areas of the texture to have more specular reflection than others: some parts of a texture, e.g. metal parts or areas worn smooth, are going to specularly reflect more than other parts of a texture.</p>
<p >A specular map is a single channel grayscale file encoding how reflective an area is for all locations on the surface.</p>
<h4><a class="anchor" id="autotoc_md148"></a>
Parallax mapping (`bumpparallaxworld`)</h4>
<ul>
<li>Note that bump is currently required to assign parallax to a texture, even though the two are not necessarily required to be together. There are very few circumstances in which it is possible to justify having parallax and not normal mapping.</li>
</ul>
<p >Parallax mapping changes how visible parts of the texture are depending on the observers' position relative to them. This is different than normal mapping in that normal mapping merely reduces the intensity of light from regions facing away from you, while parallax mapping reduces its visible size. Together, parallax and normal mapping can create a fairly convincing substitute for actual geometry, though both have visible issues in their approximations at shallow angles.</p>
<p >A parallax map (also called a heightmap, as it encodes vertical position) is a single channel, which can be either its own grayscale file or the alpha channel of the normal map.</p>
<h4><a class="anchor" id="autotoc_md149"></a>
Triplanar mapping (`triplanarworld`)</h4>
<p >Triplanar mapping involves mapping the texture from three directions (x,y,z) rather than one and using the information from those three orientations to allow the texture to be mapped accurately at any orientation (rather than having significant error at any orientation other than that of the cube face it occupies). This is most useful for patching seams in compound curvature where no patching of the seam with <code>voffset</code> or <code>vrotate</code> is possible.</p>
<p >Because triplanar mapping is fairly expensive, it is not recommended to be used unless it is visibly needed. Triplanar mapping also disallows texture transforms such as <code>vrotate</code>, so it cannot be used where texture rotations are needed.</p>
<h4><a class="anchor" id="autotoc_md150"></a>
Triplanar detail mapping (`triplanardetailworld`)</h4>
<p >While standard triplanar mapping is useful for blending a texture with itself, blending a texture with another according to angle is possibly useful (maybe???) to smoothly transition without blendmaps.</p>
<p >The most plausible use case for <code>triplanardetailworld</code> would be to blend three textures together on rough terrain, using the two textures for triplanar detail mapping and laying a blendmap over the top of it for the third. Otherwise, just using blendmap is preferable unless under some very strict map size restrictions or consistency of the blend with respect to angle is critical.</p>
<p >To add the triplanar detail shader to a texture, setting the shader to <code>triplanardetail*world</code> and declaring any normal/spec/etc. maps should be done as usual.</p>
<p >The vslot to be blended should then be declared using <code>texdetail &lt;vslot&gt;</code> along with other texture commands (e.g. <code>texscale</code>) at the end.</p>
<h4><a class="anchor" id="autotoc_md151"></a>
Glow mapping (`glowworld`)</h4>
<p >Glow mapping makes certain of the textures always be lit. This is typical for lights fixtures and computer equipment textures as well as other objects which are always lit.</p>
<p >The glow map is an intensity map of the areas for the engine to glow. It can be given in full RGB color for colored glow effects.</p>
<p >Note that this glow effect merely fixes the brightness of the texture to a specified level. It does not actually create a light entity or light nearby areas, which must be done with an actual light entity.</p>
<h2><a class="anchor" id="autotoc_md152"></a>
5.2 Lighting</h2>
<p >Libprimis' light and shadow system is built on a deferred rendering pipeline and is the main difference between it and older engines such as Cube 2. This deferred pipeline offers advantages largely in the quantity of lights that can be dynamically rendered onto the scene; however, it is not superior to Cube 2's forward rendering pipeline in all aspects. The Libprimis rendering pipeline is essentially the same as Tesseract's, and is outlined here.</p>
<p >There are essentially three types of lights in the engine:</p><ul>
<li>Sunlight</li>
<li>Dynamic lights</li>
<li>Static lights (map entities)</li>
</ul>
<p >In the renderer, the latter two are treated in largely similar ways, while sunlight is in a privileged position in the engine, being the only source for which the engine's global illumination is enabled (due to performance issues).</p>
<h3><a class="anchor" id="autotoc_md153"></a>
5.2.1 Shadow Atlas</h3>
<p >The engine's renderer uses a texture called a <em>shadow atlas</em> to cache the mapping of lights onto surfaces in the game. The shadow atlas is a monochromatic texture stored the GPU, 4096x4096 in size (32Mib of VRAM), and contains the depth mappings of every light currently being rendered. The shadow atlas does not have strong protections limiting its occupancy and therefore excessive use of light entities can cause the shadow atlas to overflow and create visual artifacts.</p>
<p >The shadow atlas is a depth buffer which maps how far parts of the scene are from their sources. This is necessary for lights to determine how far away the things they are lighting are so as to facilitate appropriate light intensities.</p>
<p >The depth of the shadow atlas can be changed from its default depth of 16 bits per pixel (16bpp) to 32 bits by changing the <code>smdepthprec</code> variable. In general, however, there is essentially no benefit to doubling the depth of the shadow atlas to 32 bits.</p>
<h3><a class="anchor" id="autotoc_md154"></a>
5.2.2 Shadow Map</h3>
<p >The shadow map is the actual texture which gets applied to textures ingame. Using the depth information encoded in the shadow atlas, the shadow map contains brightness information for lights which are being rendered. Like the shadow atlas, the shadow map is square and monochromatic, but unlike the shadow atlas, the shadow map size is variable and can be adjusted from resolutions of 2^10 (1024x1024) to 2^14 (16384x16384), an increase of 256 times. This large range in shadow map size allows the engine's shadow map to scale in performance to accomodate both the high performance of modern dedicated GPUs as well as integrated graphics up to several years of age.</p>
<p >While the shadow map is monochromatic, the engine is indeed capable of lighting in color. Color is not required in the shadow map, however, as light sources are monochromatic; the final rendering output is modulated by the light entity's particular color from the monochromatic shadow map. In doing so, Tesseract's renderer saves the overhead of three channels per bit (or conversely, increases the allowable precision by three times).</p>
<h3><a class="anchor" id="autotoc_md155"></a>
5.2.3 Shadow Map Filtering</h3>
<p >The shadow map texture does not generally line up with shadow features, causing ugly zig-zag aliasing which is particularly noticible at low shadow map resolutions. To resolve this, the shadow map may be smoothed by different, increasingly finer and more resource intensive methods.</p>
<p >The simplest and cheapest method, used by <code>smfilter 1</code>, is rotated grid filtering. This filtering method is a simple antialiasing filter that reduces "jaggies" in the shadowmap by attempting to alias them to a more beneficial plane.</p>
<p >The two finer methods are increasingly wide weighted filters which can be fed by either a simple bilinear tap method or by texture gathering. The latter is the highest fidelity method, but the bilinear method benefits from native driver support on modern GPUs. The size of the filter is either 3x3 for <code>smfilter 2</code> or 5x5 for <code>smfilter 3</code>; naturally, the wider filter is more compute intensive.</p>
<p >The use of bilinear taps or texture gather taps is controlled by the <code>smgather</code> boolean variable.</p>
<p >Generally, however, shadow map filtering is a significantly faster way to remove ugly shadow map aliasing than shadow map resolution increases, though shadow filtering cannot construct sharper shadows like high shadow map resolutions are able to do.</p>
<h3><a class="anchor" id="autotoc_md156"></a>
5.2.4 Cascaded Shadow Maps (CSM)</h3>
<p >The sunlight in Libprimis is provided by a cascaded shadow map for maximum performance while retaining high angular sharpness. The cascaded shadow map, which for the sunlight is simply planar (as the sunlight comes collimated from infinitely far away, there is no point in a 3d projection), consists of multiple shadow maps of the same orientation in consecutively larger sizes. The contents of a higher resolution shadow map (and its consequentially smaller angular size) are cut out of larger shadow maps.</p>
<p >The result of cascaded shadowmapping is that the sunlight map is increasingly higher resolution for regions closer to the camera location. This allows for relatively cheaper, lower resolution shadowmapping of faraway sunlit locations while maintaining good angular resolution up close.</p>
<p >In effect, cascaded shadow mapping is similar to mipmapping in its final form: lessening distant rendering load by utilization of low resolution textures.</p>
<p >Relevant CSM commands:</p>
<ul>
<li><code>csmbias &lt;value&gt;</code></li>
<li><code>csmbias2 &lt;value&gt;</code></li>
<li><code>csmcull &lt;boolean&gt;</code> Toggles masking of smaller CSM within larger ones.</li>
<li><code>csmdepthmargin &lt;value&gt;</code></li>
<li><code>csmdepthrange &lt;value</code></li>
<li><code>csmfarplane &lt;value&gt;</code> Sets the size in cubits of the largest CSM.</li>
<li><code>csminoq &lt;boolean&gt;</code></li>
<li><code>csmnearplane &lt;value&gt;</code> Sets the min size in cubits for the smallest CSM.</li>
<li><code>csmmaxsize &lt;pixels&gt;</code> Sets the size CSM texs relative to the shadow atlas.</li>
<li><code>csmpolyfactor &lt;value&gt;</code></li>
<li><code>csmpolyfactor2 &lt;valie&gt;</code></li>
<li><code>csmpolyoffset &lt;value&gt;</code></li>
<li><code>csmpolyoffset2 &lt;value&gt;</code></li>
<li><code>csmradiustweak &lt;value&gt;</code></li>
<li><code>csmshadowmap &lt;boolean&gt;</code> Toggles rendering of the CSM (&amp; therefore sunlight)</li>
<li><code>csmsplits &lt;value&gt;</code> Sets the number of CSM levels to use.</li>
<li><code>csmsplitweight &lt;value&gt;</code> Bias towards splitting CSM close (high) or far (low).</li>
</ul>
<h3><a class="anchor" id="autotoc_md157"></a>
5.2.5 Global Illumination (GI)</h3>
<p >Global illumination, also known as indirect lighting, is the illumination of surfaces by the light reflected off of other surfaces. Global illumination assumes diffuse reflection: that light that is shone upon surfaces bounces out at random directions at an equal rate. While this is not quite exactly true physically, it is a very good approximation to how lighting actually does diffusely reflect.</p>
<p >The global illumination in Libprimis is calculated via the Radiance Hints algorithm, which allows for a cheap approximation of indirect lighting via a collection of <em>taps</em> placed automatically by the engine in the level. These taps have light seeded by the values of a reflective shadow map (RSM) that is calculated from the global sunlight (and not on-map light entities). The taps then exchange with each other light "packets" which are then used to determine the brightness of the surrounding area. The light "packets" recieved are directional, so the taps store the light values in a low-order multipole expansion of spherical harmonics (the cheapest way to do so).</p>
<p >The use of global illumination is to ameliorate excessive point lighting (which is dynamic and therefore relatively expensive) by spreading the global sunlight around the level. As this global lighting is fairly inexpensive, levels should use sunlight + GI when possible.</p>
<h4><a class="anchor" id="autotoc_md158"></a>
The Reflective Shadow Map (RSM)</h4>
<p >The RSM, unlike the shadow map, stores its values in a total of six channels and two logical maps: the diffuse color of surfaces the sunlight impinges upon is necessary to determine the color of the light which is diffusely reflected off of those surfaces, as well as the orientation of those surfaces to determine how strongly light has hit those surfaces. No depth map is needed in this case: the sunlight, which comes from the far-field, does not meaningfully attenuate within the scale of the map.</p>
<p >The RSM is by default a quarter the resolution of the standard shadow map: the radiance hint taps generally don't have enough resolution to take advantage of a very sharp map, and the RSM requires six channels compared to the shadowmap's two.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
5.3 Transparency</h2>
<p >Transparency, also known as alpha, applies to objects which are partially clear, but have some level of visibility, including with respect to other non-trivial shaders (like specular or parallax mapping). Transparency is used by glass material as well as by geometry which has had alpha material applied to it.</p>
<p >Transparency support in Libprimis is largely motivated by the particular rendering architecture included therein. As a deferred renderer, which composites full-scene maps of particular properties, Tesseract faces steep costs to having multiple rendering layers (rendering a surface blended with another surfaces). The compromise solution, while rather limited, does allow for limited (single-layer) transparency.</p>
<h3><a class="anchor" id="autotoc_md160"></a>
5.3.1 Transparency Stenciling</h3>
<p >Transparent regions in the engine, as marked by alpha material for cube geometry, is rendered in a seperate step from ordinary geometry. The background geometry is rendered with the transparency removed as usual, and then following this the rendering pass is done over for transparent regions and then layered over the top.</p>
<p >Multiple transparency passes have rather poor performance, and as such arbitrary layers of transparency are rather non-performant due to the costs of making arbitrary numbers of transparency stencils followed by arbitrary numbers of rendering passes. Not only is the shading costs high for such an approach, but also the memory space and bandwith requirements for such an arrangement.</p>
<h3><a class="anchor" id="autotoc_md161"></a>
5.3.2 Backface Transparency</h3>
<p >A limited form of two-layered transparency, however, is supported by the engine. The geometry that is flagged as alpha by the presence of alpha material can optionally have its backface (the face visible from the other side of the transparent region) rendered along with the front face. This requires extra graphics resources, however, as an additional transparency pass is required (though being on the backface of an already flagged region simplifies other facets of transparency), and generally is only recommended where it can emulate two seperate panes of reflective material.</p>
<p >This backface alpha property is enabled whenever the texture slot's <code>alpha</code> property is set to a value greater than zero.</p>
<h2><a class="anchor" id="autotoc_md162"></a>
5.4 Screenspace Posteffects</h2>
<p >Screenspace posteffects are a family of methods which use raster buffers (essentially cached images) rather than the underlying geometry in order to do their effects. These effects are fairly inexpensive, owing to the fact that GPUs are very good at manipulating raster images, and as such they can approximate techniques that are otherwise impractical to implement.</p>
<h3><a class="anchor" id="autotoc_md163"></a>
5.4.1 Screenspace Reflection (SSR)</h3>
<p >Screenspace reflection may be the most well-known reflection technique as well as the most well-known screenspace effect, as it allows for a relatively cheap rendition of a notoriously difficult problem in game engine design: realtime, responsive reflections. Screenspace reflections, indeed, is by far the fastest and cheapest realtime reflection method, but it has traps and idiosyncracies that need to be made aware to artists and level designers.</p>
<p >Screenspace reflection works by mapping the output frame onto itself, taking a nearly-rendered frame and mapping this already-rendered frame onto reflected surfaces on the level. This is vastly cheaper than doing a full reflection pass, but at a cost: the only information the SSR pipeline has is that which is located in the field of view. Looking into a mirror, for example, can't be done with SSR, as the camera's location is not located at the location of the mirror but rather that of the player, and of course, the player can't see their own face through their own eyes.</p>
<p >Screenspace reflection, then, is mostly useful only for glancing views of reflective surfaces, which is usually adequate for non-glaringly reflective surfaces: the Fresnel effect in physics phys limits the reflectivity of most real-world non-metallic surfaces to only occur at glancing angles.</p>
<p >SSR should usually only be used, then, for non-metallic surfaces which will nearly always have their reflections mapped on the screen space itself: floors and other horizontal surfaces in particular are excellent for this.</p>
<p >In spite of these drawbacks, however, SSR is generally the cheapest reasonable way to provide the general appearance of reflectivity, and this is often good enough for casual users such as video gamers who are presumably concentrated on other things.</p>
<p >Currently, Libprimis only uses SSR for its water material's top surface, which satisfies nearly every condition where SSR is applicable: it's horizontal, non-metallic, and additionally its random movement distorts reflections, making extreme resolution less important.</p>
<h3><a class="anchor" id="autotoc_md164"></a>
5.4.2 Screenspace Ambient Occlusion (SSAO)</h3>
<p >A particular phenomenon of light propagation in real life is the darkening of corners by the lack of available space for light to propagate inwards from. A location in the corner created by two walls, for example, has a "field of view" of only a quarter sphere, versus the half sphere visible from a point located in the middle of a wall. Likewise, the junction of a ceiling/floor and two walls only allows 1/8th of a sphere's worth of light into its vicinity, darkening it further than a two-wall corner would.</p>
<p >These effects, in a perfect world, would be handled by high-resolution indirect lighting techniques that calculate the diffuse bounce off of all surfaces and compensate for this behavior. However, this is very expensive graphics-wise indeed, and as such a crude approximation is rendered in the screenspace.</p>
<p >This screenspace effect works by looking at the depth buffer, an image indicating how far objects on the screen are away from the camera, and darkening valleys found in the depth buffer. This is vastly cheaper than sampling geometry itself (as a depth buffer, as a single channel raster map, is very fast to manipulate) and therefore allows for the simulation of the darkness generated by the topology of the region. This darkening is then filtered to improve smoothness, creating a realtime darkening effect of corners ingame.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
5.4.3 Screenspace Refraction</h3>
<p >A screenspace effect only applicable to transparent surfaces, such as glass and alpha material, refraction emulates a particular effect that occurs when light travels through optically dense surfaces such as glass. At material boundries, light gets bent according to the surface normal of the boundary and the density of the material, manipulating otherwise collimated light and distorting it.</p>
<p >While refraction technically should also create a parallax effect when there is only one boundary (such as that which a pencil in a glass of water does), implementing this is a nontrivial effect and also not a typical use case (nearly all transparent volumes ingame are panes of some sort). As such, screenspace refraction assumes that the volume itself is of relatively trivial thickness, greatly simplifying the need for additional parallax calculations.</p>
<p >Screenspace refraction, then, distorts pixels in a region stenciled as transparent using the transparent surface's topside normal map, providing the impression that the imperfections in the material distorted the light coming through it.</p>
<h2><a class="anchor" id="autotoc_md166"></a>
5.5 Antialiasing</h2>
<p >Antialiasing is a means of overcoming particular artifacts common to nearly every type of raster graphics.</p>
<p >Raster graphics, by far the most common type of display rendering (used on essentially all computers, TVs, and handheld electronics) rely on a grid ("raster") on which color values can be placed. As this grid is (usually) square-sided, attempts to render lines which are not parallel to this grid become problematic, as there must be a skip pattern:</p>
<div class="fragment"><div class="line">line of slope -1/10:</div>
<div class="line"> </div>
<div class="line">%%%%%%%%%%</div>
<div class="line">          %%%%%%%%%%</div>
<div class="line">                    %%%%%%%%%%</div>
<div class="line">                              %%%%%%%%%%</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">line of slope -1/4:</div>
<div class="line"> </div>
<div class="line">%%%%</div>
<div class="line">    %%%%</div>
<div class="line">        %%%%</div>
<div class="line">            %%%%</div>
<div class="line">                %%%%</div>
<div class="line">                    %%%%</div>
<div class="line">                        %%%%</div>
<div class="line">                            %%%%</div>
<div class="line">                                %%%%</div>
<div class="line">                                    %%%%</div>
<div class="line"> </div>
<div class="line">straight line:</div>
<div class="line"> </div>
<div class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</div>
</div><!-- fragment --><p >As we can see, the slanted lines placed onto the raster grid of text column are not particularly nice, and there's jumps every so often to approximate perfect angled lines.</p>
<p >The best thing we can do, then, is to create hints that blend together these discontinuities as nicely as we can manage with the grid, with less intense color in the surrounding highlights:</p>
<div class="fragment"><div class="line">line of slope -1/10:</div>
<div class="line"> </div>
<div class="line">%%%%%%%%%%**</div>
<div class="line">        **%%%%%%%%%%**</div>
<div class="line">                  **%%%%%%%%%%**</div>
<div class="line">                            **%%%%%%%%%%</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">line of slope -1/4:</div>
<div class="line"> </div>
<div class="line">%%%%*</div>
<div class="line">   *%%%%*</div>
<div class="line">       *%%%%</div>
<div class="line">           *%%%%*</div>
<div class="line">               *%%%%*</div>
<div class="line">                   *%%%%*</div>
<div class="line">                       *%%%%*</div>
<div class="line">                           *%%%%*</div>
<div class="line">                               *%%%%*</div>
<div class="line">                                   *%%%%</div>
<div class="line"> </div>
<div class="line">straight line:</div>
<div class="line"> </div>
<div class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</div>
</div><!-- fragment --><p >The examples above, of course, are very crude, but smudging the fringes of edges like this is essentially the whole idea of antialiasing. Antialiasing, however, requires smoothing an area of many pixels (about two million a frame for a 1080p display) and therefore some serious hacks are needed to pump pixels very quickly.</p>
<p >Libprimis' implementation of screenspace antialiasing techniques, it should be noted, are mutually exclusive: only one can take effect at a time. Generally, however, there are limited benefits to stacking AA techniques (beyond MSAA), and so providing multiple screenspace AA techniques is not worth the effort.</p>
<h3><a class="anchor" id="autotoc_md167"></a>
5.5.1 Supersample Antialiasing (SSAA)</h3>
<p ><b>SSAA is not implemented in Libprimis. It is described here as a useful basis for the more advanced antialiasing techniques.</b></p>
<p >Supersample antialiasing is perhaps the simplest antialiasing method to understand. SSAA simply renders everything at a higher resolution, and then is able to average down this high-resolution output to the lower-res display. This method is "perfect" in that no parts of the scene get missed by SSAA pass (of course, everything gets scaled up in view), but it is very expensive, especially for a deferred renderer which buffers the output scene in many images that get composited together; to use SSAA 4x on a 1080p screen is as expensive as rendering 4k native.</p>
<p >For this reason, the "naive" SSAA method is very seldom used for realtime graphics applications because it is simply too slow for the antialiasing it is capable of doing. Generally, cranking other methods of AA up to the same performance cost as a given SSAA level generate much smoother results, as they can bring more antialiasing power to bear on the areas of the scene that are actually jaggy.</p>
<p >In particular, SSAA implementations tend to be very intensive on the memory subsystem of graphics cards: working with huge buffers at ~4k resolution requires a lot of shuttling of graphics information between the cache and VRAM of a graphics card.</p>
<h3><a class="anchor" id="autotoc_md168"></a>
5.5.2 Multisample Antialiasing (MSAA)</h3>
<p >Multisample antialiasing is a significantly more useful AA technique than SSAA, but it suffers from many of the same issues that SSAA does. MSAA works by smoothing only the boundaries of <em>fragment shaders</em>, i.e. the edges of geometry in the level. In doing so, it can skip past smoothing texture faces which are usually not so abrupt as those created by geometry discontinuities (particularly those boundaries where one face ends and some other geometry is farther away, such as the outline of a foreground chair against a back wall).</p>
<p >This is still quite expensive however, especially in a deferred renderer which presents many different images which have yet to be composited to a final output image. This then dictates that MSAA implementations have to do a MSAA pass over every buffer, of which there are several, in order to properly antialias the scene; this then makes MSAA several times slower in a game like Libprimis than a forward-rendered game like Quake III or Cube 2.</p>
<p >Like SSAA, MSAA tends to have large memory bandwidth demands relative to screenspace antialiasing methods.</p>
<p >For this reason, while MSAA is included in Libprimis, it rapidly becomes prohibitively expensive at high levels. For high performance antialiasing in a deferred engine like Libprimis, a different technique is needed: screenspace antialiasing.</p>
<h3><a class="anchor" id="autotoc_md169"></a>
5.5.3 Fast Approximate Antialiasing (FXAA)</h3>
<p >Fast approximate antialiasing is, as its helpfully honest name implies, a way to quickly approximate nicer forms of antialiasing such as MSAA. To do this, FXAA discards the edge detection by individual fragment shader on the back end that MSAA uses and instead opts to sample only the (nearly) final output image.</p>
<p >FXAA uses a shader-powered filter instead to calculate what parts of the scene are the most "sharp" and then uses a blur filter to smooth them out. This works very well indeed to smooth out the sharp parts of the output image. However, as FXAA has no knowledge of the background geometry which created the scene, it has to guess at what parts are problematically sharp. This causes the FXAA method to tend to oversmooth large parts of the scene that were supposed to remain sharp, leading to FXAA be considered a "grease filter" shader that blots out sharpness from the scene at large.</p>
<p >Unlike SSAA/MSAA however, FXAA is quite cheap with respect to memory bandwidth, instead utilizing the math units in a GPU more heavily to do its calculations. Usually, this ends up being cheaper than MSAA/SSAA, especially for a deferred engine like Libprimis, but it is worth noting that screenspace methods like FXAA do utilize a different part of the GPU heavily than MSAA/SSAA.</p>
<h3><a class="anchor" id="autotoc_md170"></a>
5.5.4 Temporal Quincunx Antialiasing (TQAA)</h3>
<p >A rather clever form of screenspace antialiasing, TQAA borrows the information from the previous frame to use as data to antialias the scene much as SSAA does, but because it borrows information that already had its rendering costs sunk, it is much faster than a comparable SSAA 2x implementation.</p>
<p >The "quincunx" in TQAA, refering to a cross shape, is appropriate in that the previous frame is overlaid offset by half a pixel in each dimension:</p>
<div class="fragment"><div class="line">Here the recycled frame &quot;y&quot; is laid offset to the current frame &quot;x&quot;:</div>
<div class="line"> </div>
<div class="line">   x   x   x   x   x</div>
<div class="line"> </div>
<div class="line">     y   y   y   y   y</div>
<div class="line"> </div>
<div class="line">   x   x   x   x   x</div>
<div class="line"> </div>
<div class="line">     y   y   y   y   y</div>
<div class="line"> </div>
<div class="line">   x   x   x   x   x</div>
<div class="line"> </div>
<div class="line">     y   y   y   y   y</div>
</div><!-- fragment --><p >As one can see, the "y" pixels from the recycled frame have four nearby "x" neighbors from the current frame, creating a quincunx shape like those formed by the five pip side on a six-sided die.</p>
<p >Not all is perfect with TQAA, however, much as any other hasty approximation is. TQAA in particular is incapable of dealing with fast-moving and shape changing objects like players or projectiles, as they move fast enough relative to the frame rate that the TQAA method has trouble using stale information for antialiasing with. However, in general, TQAA resolves nicely antialiasing issues with static, predictable geometry, as levels tend to be mostly made up of.</p>
<p >TQAA, then, has to calculate what parts of an old frame it can map to a new one, eating up some shader resources in the process. In general, however, TQAA is quite cheap and decently effective for all but the most picky of eyes.</p>
<h3><a class="anchor" id="autotoc_md171"></a>
5.5.5 Subpixel Morphological Antialiasing (SMAA)</h3>
<p >SMAA is the "crown jewel" antialiasing method included in Libprimis' parent engine, Tesseract, and it is generally the most effective method overall for antialiasing; it uses TQAA and MSAA in addition to its own method at higher levels for additional scalibility.</p>
<p >SMAA works by fitting parts of the screenspace area to particular common edge types ("morphologies"): (plain straight edges, curves, etc.) to treat specifically. This is not quite as simple as FXAA, as FXAA simply looks for big changes to smooth, and in return avoids the "grease filter" effect over all high contrast geometry that FXAA is known to exhibit. Doing so requires some shader power, like other screenspace antialiasing methods. In general, however, SMAA, particularly the base level without additional AA methods included, is superior to and roughly as expensive as FXAA.</p>
<p >Higher levels of SMAA utilize additional pixels stolen from TQAA and MSAA 2x in order to aid the filterer in sorting out interesting areas of the scene.</p>
<p >Generally, SMAA is the best general-purpose antialiasing method available in Libprimis and is generally recommended as the default; methods like high MSAA values are only particularly useful for promotional purposes (e.g. screenshots).</p>
<h1><a class="anchor" id="autotoc_md172"></a>
6 Actors and Models</h1>
<p >Actors are the entities that play the game: this includes human controlled players and bot controlled players. At this time, no support for nonplayer models exists: the only actors supported are ones that take the form of the player model.</p>
<p >Actors are enlarged humans with a height of 2.5m (8') and a breadth of about 1m (3' 3"). This slightly exaggerated size is such that a player can jump onto a 1m tall box without being too exaggerated. As a result, players can fit in 3m by 1m corridors without a problem, and crouch to fit in 2m by 1m corridors if necessary.</p>
<p >As the most intensive use of models is here in the creation of actors, this section also covers the technical implementation of the game's models.</p>
<h2><a class="anchor" id="autotoc_md173"></a>
6.1 Actor Objects</h2>
<p >Actors are objects ingame with a large number of properties kept which are synced to other players by the server ingame. This is significantly larger than that of conventional entities and is synced much more carefully, as they are the entities which are directly manipulated by players.</p>
<h3><a class="anchor" id="autotoc_md174"></a>
6.1.1 Actor Entity Properties</h3>
<p >Actors are stored as an object <code>gameent</code> which is the object synced to other clients. The information kept for each actor is kept regardless of their ownership by a human player or a bot AI: they both interact with the engine in the same way.</p>
<p >Actors store the following properties in their object fields:</p>
<ul>
<li>int <code>weight</code> weight of the player for hitboxes</li>
<li>int <code>clientnum</code> the server ID for the player</li>
<li>int <code>privilege</code> the level of authentication for the player</li>
<li>int <code>lastupdate</code> time in ms since the last packet reception</li>
<li>int <code>plag</code> packet lag (time in ms between packets)</li>
<li>int <code>ping</code> ping time for client</li>
<li>int <code>lifesequence</code></li>
<li>int <code>respawned</code></li>
<li>int <code>suicided</code></li>
<li>int <code>lastpain</code></li>
<li>int <code>lastaction</code></li>
<li>int <code>lastattack</code></li>
<li>int <code>attacking</code></li>
<li>int <code>lasttaunt</code></li>
<li>int <code>lastpickup</code></li>
<li>int <code>lastpickupmillis</code></li>
<li>int <code>flagpickup</code></li>
<li>int <code>frags</code> frags (kills) so far in the current game match</li>
<li>int <code>flags</code> flags captured so far in the current game match</li>
<li>int <code>deaths</code> deaths so far in the current game match</li>
<li>int <code>totaldamage</code></li>
<li>int <code>totalshots</code></li>
<li>int <code>edit</code></li>
<li>float <code>deltayaw</code> change in yaw since last update</li>
<li>float <code>deltapitch</code> change in pitch since last update</li>
<li>float <code>deltaroll</code> change in roll since last update</li>
<li>float <code>newyaw</code></li>
<li>float <code>newpitch</code></li>
<li>float <code>newroll</code></li>
<li>float <code>smoothmillis</code></li>
<li>string <code>name</code> client name shown to other players</li>
<li>string <code>info</code></li>
<li>int <code>team</code> 1 (blue) or 2 (red): team the player belongs to</li>
<li>int <code>playermodel</code> index of player model</li>
<li>int <code>playercolor</code> index of player color (NOT hex color)</li>
<li>ai::aiinfo <code>ai</code></li>
<li>int <code>ownernum</code></li>
<li>int <code>lastnode</code></li>
<li>vec <code>muzzle</code></li>
</ul>
<p >and the following functions:</p>
<ul>
<li><code>gameent</code></li>
<li>void <code>respawn</code></li>
<li><code>~gameent</code></li>
<li>void <code>hitpush</code></li>
<li>void <code>startgame</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md175"></a>
6.2 Models</h2>
<p >Models in Libprimis are not especially first-class citizens compared to the octree geometry that the world is built on, but they still play an important role, particularly in player models.</p>
<h3><a class="anchor" id="autotoc_md176"></a>
6.2.1 Model Format Overview</h3>
<p >Models for Libprimis currently are supported in two formats: OBJ (aka Wavefront) and MD5 (aka Doom 3). These two formats do not particularly overlap in their utility and a very terse overview of the formats is given here. Neither of these formats are unique to Cube and OBJ in particular is extremely widely used.</p>
<h4><a class="anchor" id="autotoc_md177"></a>
OBJ (Wavefront)</h4>
<p >OBJ models are most useful for static, non-animated objects such as scenery, level assets, and other applications that do not rely on a complicated, feature intensive model format. OBJ files can store vertex data and UV mapping to allow accompanying texture files to be used to skin them. OBJ is a plaintext, easy to read (compared to other formats) format and therefore is very commonly used for basic models in all types of 3D graphics applications.</p>
<h4><a class="anchor" id="autotoc_md178"></a>
MD5 (Doom 3)</h4>
<p >The MD5 format is the in-house format for the id 4 engine most notably used in Doom 3. It is a game-centric model format that allows for a skeleton to animate it (using pre-provided animation files) and therefore allows for animation of characters or other entities in the game. MD5 therefore is the model format of choice for the player model, as it requires animations to allow the player to move realistically ingame.</p>
<h3><a class="anchor" id="autotoc_md179"></a>
6.2.2 Basic Model Commands</h3>
<p >These are commands which are available to all formats, including static, non animated ones such as Wavefront (OBJ).</p>
<ul>
<li><code>&lt;fmt&gt;skin [meshname] [tex] [masks]</code></li>
<li><code>&lt;fmt&gt;spec [tex] [scale]</code></li>
<li><code>&lt;fmt&gt;gloss [tex] [type]</code> type ranges 0..2</li>
<li><code>&lt;fmt&gt;glow [tex] [pct] [del] [pulse]</code></li>
<li><code>&lt;fmt&gt;alphatest [mesh] [cutoff]</code></li>
<li><code>&lt;fmt&gt;cullface [mesh] [cullface]</code></li>
<li><code>&lt;fmt&gt;color [mesh] [r] [g] [b]</code></li>
<li><code>&lt;fmt&gt;bumpmap [mesh] [tex]</code></li>
<li><code>&lt;fmt&gt;decal [mesh] [tex]</code></li>
<li><code>&lt;fmt&gt;fullbright [mesh] [bright]</code></li>
<li><code>&lt;fmt&gt;shader [mesh] [shader]</code></li>
<li><code>&lt;fmt&gt;scroll [mesh] [x] [y]</code></li>
<li><code>&lt;fmt&gt;noclip [mesh] [bool]</code></li>
<li><code>&lt;fmt&gt;settricollide [mesh]</code></li>
<li><code>&lt;fmt&gt;link [parent] [child] [tag] [x] [y] [z]</code></li>
<li><code>&lt;fmt&gt;load [model] [smooth]</code></li>
<li><code>&lt;fmt&gt;tag [tagname] [tx] [ty] [tz] [rx] [ry] [rz]</code></li>
<li><code>&lt;fmt&gt;pitch [scale] [offset] [min] [max]</code></li>
<li><code>&lt;fmt&gt;anim [anim] [frame] [range] [speed] [priority]</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md180"></a>
6.2.3 Animated Model Commands</h3>
<p >These are commands which are only available to animated model formats, of which the only current one is MD5.</p>
<ul>
<li><code>&lt;fmt&gt;load [mesh] [skel] [smooth]</code></li>
<li><code>&lt;fmt&gt;tag [name] [tag] [tx] [ty] [tz] [rx] [ry] [rz]</code></li>
<li><code>&lt;fmt&gt;pitch [name] [target] [scale] [min] [max]</code></li>
<li><code>&lt;fmt&gt;pitchtarget [name] [anim] [offset] [min] [max]</code></li>
<li><code>&lt;fmt&gt;pitchcorrect [name] [target] [scale] [min] [max]</code></li>
<li><code>&lt;fmt&gt;hitzone [id] [mask]</code></li>
<li><code>&lt;fmt&gt;anim [anim] [animfile] [speed] [priority] [startoffset] [endoffset]</code></li>
<li><code>&lt;fmt&gt;animpart [maskstr]</code></li>
<li><code>&lt;fmt&gt;adjust [name] [yaw] [pitch] [tx] [ty] [tz]</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md181"></a>
7. User and System Interfaces</h1>
<p >The game is largely accessed by the user using various interfaces defined in the engine that power the game's user experience. This includes the menu system and heads-up display (HUD), as well as the somewhat lower-level (but still exposed to the player) console and scripting system.</p>
<h2><a class="anchor" id="autotoc_md182"></a>
7.4 Scripting</h2>
<p >Scripting in Libprimis is done using the language common to the entire Cube series of engines, Cubescript. Cubescript, at least the part that can be considered consistent across games, is a very simple language; however, it has very large numbers of commands which extend it and make it useful.</p>
<h3><a class="anchor" id="autotoc_md183"></a>
7.4.1 Cubescript Semantics</h3>
<p >Cubescript itself has a simple set of semantics which defines how operations are carried out. There is essentially one type of object in Cubescript, the alias, and a small set of native operations to make control structures possible. Notably, and as a result of being a scripting language rather than a general purpose one, Cubescript's actual control operations are not explicitly codified into the language's semantics and instead are implemented as commands on the same tier as typical game modifying commands.</p>
<h4><a class="anchor" id="autotoc_md184"></a>
Lazy Execution `[]`</h4>
<p >The <code>[]</code> chars define a block of code to be evaluated when necessary (at the end of the parser's job, after other parts of the code have been resolved). This means that <code>[]</code> chars are very useful for control commands, as they allow the parser to defer execution of the material within them until necessary. These blocks can be eliminated by the effects of commands (they can be entirely ignored if the execution path does not run through them).</p>
<p >As expected for a delimiting pair of chars, the <code>[]</code> braces delimit the order of operations: interior nested pairs of <code>[]</code> braces are executed before outside ones. However, generally, disambiguation of the order of operations should be done by the <code>()</code> parentheses defined below.</p>
<p >A notable side effect of the way brackets and parens work within the parser is that they must be defined inline with the command or assignment which they belong to. This means that while the following Cubescript is valid:</p>
<div class="fragment"><div class="line">foo = [</div>
<div class="line">    <span class="stringliteral">&quot;bar&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;baz&quot;</span></div>
<div class="line">]</div>
</div><!-- fragment --><p> this code cannot be parsed by the Cubescript parser. </p><div class="fragment"><div class="line">foo =</div>
<div class="line">[</div>
<div class="line">    <span class="stringliteral">&quot;bar&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;baz&quot;</span></div>
<div class="line">]</div>
</div><!-- fragment --><p >Do note that these semantics are at odds with the C++ standards for the codebase, which adopt a style similar to the latter example.</p>
<h4><a class="anchor" id="autotoc_md185"></a>
Eager Execution `()`</h4>
<p >The <code>()</code> parentheses act like the <code>[]</code> braces except that code within these are executed early, such that their actions are carried out before parsing commands outside them. This means that <code>()</code> parens are to be used for statements which determine the behavior of control commands, as their result is relevant for other parts of the code. These blocks of code are always executed, meaning that <code>()</code> chars are useless for control commands.</p>
<h4><a class="anchor" id="autotoc_md186"></a>
Assignment `=`</h4>
<p >The <code>=</code> equals sign, like in many languages, allows defining an <em>alias</em>, the unit equivalent to a variable. Aliases can not only be used like variables but also like functions, accepting arguments to a body (typically delineated by a set of braces) by defining arguments within the body as the reserved alias names <code>$arg1 $arg2 ....$arg25</code> (there is a 25 argument limit in the parser).</p>
<div class="fragment"><div class="line">foo = bar</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md187"></a>
Lookup Alias `$`</h4>
<p >The <code>$</code> symbol causes the parser to look for a defined alias with the name appended, allowing for the value of variables to be used by other functions. The behavior of this is similar to unix's <code>bash</code> shell language, while the behavior is implicit in many other languages (Cubescript interprets symbols not delineated by a <code>$</code> at the beginning as a string literal).</p>
<div class="fragment"><div class="line">foo = 1</div>
<div class="line">bar = $foo <span class="comment">//bar = 1</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md188"></a>
Literal Substitution `@`</h4>
<p >The <code>@</code> symbol causes the value stored by an alias to be directly inserted where it is called, from a scope determined by the nesting level. The <code>@</code> symbol thus allows for application in synthesis of compound alias names (by directly depositing the value of a variable in an already-in-progress string, which is then evaluated in full after the <code>@</code> symbol has taken effect).</p>
<p >Note the difference between the <code>$</code> lookup and the <code>@</code> literal substitution: </p><div class="fragment"><div class="line">foo = 1</div>
<div class="line">bar = [</div>
<div class="line">    baz = $foo</div>
<div class="line">]</div>
<div class="line">foo = 2</div>
<div class="line">bar <span class="comment">//baz = 2</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">foo = 1</div>
<div class="line">bar = [</div>
<div class="line">    baz = @foo</div>
<div class="line">]</div>
<div class="line">foo = 2</div>
<div class="line">bar <span class="comment">//baz = 1</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md189"></a>
Comments `//`</h4>
<p >Cubescript only supports inline comments (no comment blocks) using a pair of slashes. This can be done at the beginning of a line, or following the end of a written code line.</p>
<div class="fragment"><div class="line"><span class="comment">//I defined an alias `foo` here</span></div>
<div class="line"> </div>
<div class="line">foo = [</div>
<div class="line">    <span class="stringliteral">&quot;bar&quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;baz&quot;</span> <span class="comment">//I defined `baz` here</span></div>
<div class="line">]</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md190"></a>
7.4.2 Commands</h3>
<p >Commands in Libprimis are the primary way to make Cubescript perform useful work (Cubescript is entirely useless without additional commands defined) as well as cause internal changes inside the engine. Commands are bound via a rather convoluted macro process, but the important part of how they work does not require fully understanding the technicalities of the way they are bound.</p>
<h4><a class="anchor" id="autotoc_md191"></a>
Inline Commands</h4>
<p >These commands are bound in a single self-contained macro, called ICOMMAND (for, unsurprisingly, InlineCOMMAND). This macro has the following arguments:</p><ul>
<li><code>name</code>: the name of the command as called from the console or via Cubescript</li>
<li><code>nargs</code>: a string codifying the arguments the command accepts (see below)</li>
<li><code>proto</code>: the C++ types that the arguments will pass to the body</li>
<li><code>b</code>ody: the C++ logic body of the command</li>
</ul>
<h4><a class="anchor" id="autotoc_md192"></a>
Standard Commands</h4>
<p >These commands comprise of two parts: the declaration of the command, and a separate named function which is called upon the execution of the command. It is slightly less flexible than the <code>ICOMMAND</code> inline command macro in that it requires that a function be created with the command's contents. If for some reason the function and command cannot have the same name as its associated function, it is possible to use the COMMANDN macro to define both the name of the command and its related function separately.</p>
<p >This macro has the following arguments:</p><ul>
<li><code>name</code>: the name of the function to be called as well as the command's name</li>
<li><code>nargs</code>: a string codifying the arguments the command accepts (see below)</li>
</ul>
<p >Multiple commands which reference the same function by name (e.g. COMMANDN) cannot be assigned, because the macros which define them cannot redefine the dummy variables used for their instantiation.</p>
<h4><a class="anchor" id="autotoc_md193"></a>
Interpreter return types</h4>
<p >To return values to the interpreter, there are a handful of useful functions which allow this to be done.These functions should be set to "return" the desired value of a COMMAND or ICOMMAND's output (do not use the function's native return type).</p>
<ul>
<li><code>intret</code> returns an integer to the interpreter</li>
<li><code>floatret</code> returns a float to the interpreter</li>
<li><code>stringret</code> returns a string to the interpreter</li>
</ul>
<p >Returned values from commands are not displayed directly to the console at first, and must be manually displayed using <code>echo</code>.</p>
<h4><a class="anchor" id="autotoc_md194"></a>
Decoding `nargs`</h4>
<p >The <code>nargs</code> part of the command macro is used to tell the command parser what kind of arguments it should be interpreting. A single character corresponds to a single argument and codifies its type; the number of characters indicates the number of chars total.</p>
<ul>
<li><code>S</code></li>
<li><code>s</code>: a string (char *) argument</li>
<li><code>i</code>: an int (int *) argument</li>
<li><code>b</code>: a boolean (bool *) argument</li>
<li><code>f</code>: a float (float *) argument</li>
<li><code>F</code>:</li>
<li><code>E</code></li>
<li><code>T</code> a tagval (tagval *) object</li>
<li><code>t</code></li>
<li><code>e</code> an exec (uint *) code</li>
<li><code>r</code> an id (ident *) object</li>
<li><code>$</code></li>
<li><code>N</code> a number of args (int *) specifier</li>
<li><code>D</code> an (int *) specifier for a cmd that checks for a key press (e.g. movement)</li>
<li><code>C</code> a console (char *) argument to be printed</li>
<li><code>V</code></li>
<li><code>1</code></li>
<li><code>2</code></li>
<li><code>3</code></li>
<li><code>4</code></li>
</ul>
<p >For example, a command with <code>nargs</code> equal to <code>ssssif</code> would take four string arguments followed by an integer and float argument; a command with <code>nargs</code> equal to <code>fffs</code> would take three floats followed by a string.</p>
<h3><a class="anchor" id="autotoc_md195"></a>
7.4.3 Variables</h3>
<p >Variables, in the context of the Libprimis scripting system, refers to specific ingame variables which have been provided to the scripting system by way of yet another convoluted macro system. <code>VAR</code> macros allow different types of variables to be exposed to the scripting system in useful ways, meaning that options such as settings can be directly controlled via Cubescript or the console.</p>
<h4><a class="anchor" id="autotoc_md196"></a>
Integer Variables `VAR`</h4>
<p >Variables exposed to Cubescript which have the type of <code>int</code> are the most common ones used in Libprimis. These variables also take on the duty of boolean settings, ones which are very common in the realm of settings, as Cubescript carries no notion of a boolean.</p>
<p >A standard <code>VAR</code> carries the following arguments:</p><ul>
<li><code>name</code> The name of the variable, both to the engine and ingame</li>
<li><code>cur</code> The value which the variable is initiated with at the start of the game*</li>
<li><code>min</code> The minimum value that the variable is allowed to be set from ingame</li>
<li><code>max</code> The maximum value that the variable is allowed to be set from ingame</li>
</ul>
<h4><a class="anchor" id="autotoc_md197"></a>
Float Variables `FVAR`</h4>
<p >For floating-point numbers with decimals, it is possible to define accessible variables with the <code>FVAR</code> macro. This macro behaves nearly the same as the int version of the macro, with the only notable difference being the replacement of integer values by floating point ones.</p>
<p >A standard <code>FVAR</code> carries the following arguments:</p><ul>
<li><code>name</code> The name of the variable, both to the engine and ingame</li>
<li><code>cur</code> The value which the variable is initiated with at the start of the game*</li>
<li><code>min</code> The minimum value that the variable is allowed to be set from ingame</li>
<li><code>max</code> The maximum value that the variable is allowed to be set from ingame</li>
</ul>
<h4><a class="anchor" id="autotoc_md198"></a>
Hex Variables `HVAR`</h4>
<p >For hexadecimal values, it is possible to define values as a <code>HVAR</code> which makes entry and display more straightforward. This type of variable is similar to an integer variable internally otherwise.</p>
<p >A standard <code>HVAR</code> carries the following arguments:</p><ul>
<li><code>name</code> The name of the variable, both to the engine and ingame</li>
<li><code>cur</code> The value which the variable is initiated with at the start of the game*</li>
<li><code>min</code> The minimum value that the variable is allowed to be set from ingame</li>
<li><code>max</code> The maximum value that the variable is allowed to be set from ingame</li>
</ul>
<h4><a class="anchor" id="autotoc_md199"></a>
Color Variables `CVAR`</h4>
<p >For colors, it is convenient to save and use information using the widely used six-digit hexadecimal HTML format (<code>0xRRGGBB</code>), so a <code>CVAR</code> macro is provided to interface with these types of data. A <code>CVAR</code> is implicitly limited to six hex digits, naturally, but otherwise is not restricted and therefore lacks min or max arguments like the numerical <code>VAR</code> macros have.</p>
<p >A standard <code>CVAR</code> carries the following arguments:</p><ul>
<li><code>name</code> The name of the variable, both to the engine and ingame</li>
<li><code>cur</code> The value which the variable is initiated with at the start of the game*</li>
</ul>
<h4><a class="anchor" id="autotoc_md200"></a>
String Variables `SVAR`</h4>
<p >For the storage of strings, such as those used for e.g. a player's name, it is possible to define accessible string variables with the <code>SVAR</code> macro. This macro only has two arguments, unsurprisingly, as there is no logical way to set limits for its bounds like the numerical ones.</p>
<p >A standard <code>SVAR</code> carries the following arguments:</p><ul>
<li><code>name</code> The name of the variable, both to the engine and ingame</li>
<li><code>cur</code> The value which the variable is initiated with at the start of the game*</li>
</ul>
<p >*Note that the <code>cur</code> value is always true at the very beginning of the game, but can be changed ingame to differ from this value.</p>
<h4><a class="anchor" id="autotoc_md201"></a>
Persistent Variables `*VARP`</h4>
<p >Persistent variables are variables which are saved to a configuration file at the time that the program is closed. This makes it useful for settings which are generally kept the same between runs of the game.</p>
<p >The <code>*VARP</code> macros (<code>VARP</code> <code>FVARP</code> <code>HVARP</code> <code>CVARP</code> <code>SVARP</code>) all behave the same as normal variables except that the game makes sure to save them to a script to be executed when the game is started again. These variables initialize their <code>cur</code> values to their defined values as normal, but rely on a startup script to change them to their persistent states from the previous run.</p>
<h1><a class="anchor" id="autotoc_md202"></a>
8 Internal Objects</h1>
<p >A number of C++ objects are defined in the engine to facilitate manipulation in a replicable way. Many of these are geometry constructs which carry with them the algebra and geometry of the structures they describe.</p>
<p >The game also has many specific-purpose objects which are described in their particular section. This chapter is reserved for general, extensible objects with utility in many potential parts of the engine.</p>
<h2><a class="anchor" id="autotoc_md203"></a>
8.1 Vector Objects</h2>
<p >A large number of vector objects exist in the game to facilitate working with objects in 2D, 3D, 4D, quaternion, and dual quaternion vector spaces.</p>
<h4><a class="anchor" id="autotoc_md204"></a>
8.1.1 `vec`</h4>
<p ><code>vec</code> is an incredibly ubiquitous object in the engine, where it is referenced thousands of times over essentially every part of the game code. Key features of the vec object:</p>
<ul>
<li><code>vec</code> is always 3 dimensional, and has three defining float values.</li>
<li><code>vec</code> has its three arguments as either <code>x,y,z</code> or <code>r,g,b</code> (in a union)</li>
<li><code>vec</code> has many linear algebra operators defined for it: see <code>shared/geom.h</code></li>
</ul>
<p >As the <code>vec</code> object is only defined for a 3-vector, seperate classes like <code><a class="el" href="structvec2.html" title="2 dimensional vector object">vec2</a></code> and <code><a class="el" href="structvec4.html" title="A four dimensional Cartesian-space vector template.">vec4</a></code> are used to do two or four dimensional linear algebra. However, these objects are much less common and also have less operators defined for it, befitting a 3d engine where locations of objects in the world are nearly always defined as a 3d vector.</p>
<p >An important note about the <code>vec</code> object's many member functions is that they are destructive: when you call a member function such as in the following example, the state of <code>vec a</code> is changed by the call to <code>mul()</code>: </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structvec.html">vec</a> a(1,1,1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> b = 2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// `c` is (2,2,2), but `b` is ALSO (2,2,2) because mul() changes its state</span></div>
<div class="line"><a class="code hl_struct" href="structvec.html">vec</a> c = a.mul(b);</div>
<div class="ttc" id="astructvec_html"><div class="ttname"><a href="structvec.html">vec</a></div><div class="ttdoc">three dimensional vector object</div><div class="ttdef"><b>Definition:</b> geom.h:157</div></div>
</div><!-- fragment --><p> To work around this, it is typical to see what appears to be an unnecessary constructor call <code><a class="el" href="structvec.html" title="three dimensional vector object">vec(vec T)</a></code>. This is to create a new tempoary object using the constructor call which can have member functions applied to it without mangling the original vector.</p>
<p >While this property of <code>vec</code>'s many member functions is most commonly seen in <code>vec</code> objects, the same behavior also applies to other related objects, such as <code><a class="el" href="structvec2.html" title="2 dimensional vector object">vec2</a></code> or <code>ivec</code>.</p>
<h4><a class="anchor" id="autotoc_md205"></a>
8.1.2 `bvec`</h4>
<p ><code>bvec</code> is a 3d color vector object. As opposed to the standard <code>vec</code> object, which is useful mainly in world geometry, the <code>bvec</code> vector is intended for use in the color vector space. In this space, the three basis vectors are R/G/B.</p>
<p ><code>bvec</code> does not inherit properties from the standard <code>vec</code> object and is not capable of doing standard linear algebra operations like <code>vec</code> can; for this reason, it is not suitable for use in standard geometric constructions.</p>
<p >Important properties of the <code>bvec</code> object:</p>
<ul>
<li><code>bvec</code> is always 3 dimensional, and has three defining character values.</li>
<li><code>bvec</code> has its three arguments as either <code>x,y,z</code> or <code>r,g,b</code> (in a union)</li>
<li><code>bvec</code> has mostly color conversion operators defined and few normal operators</li>
</ul>
<p >Critically, values in a <code>bvec</code> are of type <code>char</code>, meaning they are one byte long and can encode values between 0 and 255. There is no notion of sign with a <code>char</code>, and indeed having colors with negative values in its channels makes no sense either.</p>
<h2><a class="anchor" id="autotoc_md206"></a>
8.2 Cube Objects</h2>
<p >Individual cube nodes, the heart of Libprimis' geometry system, are represented in the code by C++ objects. There are two main objects which define a cube in the level, which are described here.</p>
<h3><a class="anchor" id="autotoc_md207"></a>
8.2.1 `cube`</h3>
<p >The base object which defines a cube in the world. It has several attributes:</p>
<ul>
<li><code>*children</code> A pointer to an array which contains child cubes within this cube</li>
<li><code>*cubeext</code> A pointer to the extended info for the cube</li>
<li><code>union: edges faces</code> A union type containing the cube's edge/face deformation</li>
<li><code>texture[6]</code> A six-entry array containing texture indices for each face</li>
<li><code>material</code> The bitmask of the material filling this cube</li>
<li><code>merged</code> The bitmask of faces of the cubes which have been merged</li>
<li><code>union: escaped visible</code> union of unmerged children nodes/visible faces</li>
</ul>
<h3><a class="anchor" id="autotoc_md208"></a>
8.2.2 `cubeext`</h3>
<p >The extended information belonging to a cube.</p>
<ul>
<li><code>*va</code> pointer to the vertex array which the cube belongs to</li>
<li><code>*ents</code> pointer to entities within the bounds of the cube</li>
<li><code>surfaces[6]</code> vertex information for each of the cube's six faces</li>
<li><code>tjoints</code> list of cube t-joints</li>
<li><code>maxverts</code> space allocated for vertices</li>
</ul>
<p >This object contains the metadata needed for the engine to stitch cubes' faces together with other cubes into vertex arrays in a less geometry heavy fashion than naive cube rendering. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
