/* input.h: SDL input handling
 *
 * SDL handles low-level window manager and key inputs for libprimis
 * this file determines how the game parses the SDL information it is given
 *
 * includes handling for when the window manager tells the game to change state
 * and handling for how the game should react to key inputs (though obviously this
 * is rebindable by the client)
 *
 */

#include "../libprimis-headers/cube.h"
#include "../../shared/stream.h"

#include "console.h"
#include "control.h"
#include "input.h"
#include "ui.h"

#include "render/rendergl.h"
#include "render/renderwindow.h"

//sets SDL relative mouse mode to enabled if 1, 0 otherwise
VARNP(relativemouse, userelativemouse, 0, 1, 1);

bool shouldgrab = false,
     grabinput  = false,
     minimized  = false,
     canrelativemouse = true,
     relativemouse    = false;
int keyrepeatmask = 0,
    textinputmask = 0;
Uint32 textinputtime = 0;

VAR(textinputfilter, 0, 5, 1000); //delay in ms between text input events

void keyrepeat(bool on, int mask)
{
    if(on)
    {
        keyrepeatmask |= mask;
    }
    else
    {
        keyrepeatmask &= ~mask;
    }
}

void textinput(bool on, int mask)
{
    if(on)
    {
        if(!textinputmask)
        {
            SDL_StartTextInput();
            textinputtime = SDL_GetTicks();
        }
        textinputmask |= mask;
    }
    else
    {
        textinputmask &= ~mask;
        if(!textinputmask)
        {
            SDL_StopTextInput();
        }
    }
}

void inputgrab(bool on)
{
    if(on)
    {
        SDL_ShowCursor(SDL_FALSE);
        if(canrelativemouse && userelativemouse)
        {
            if(SDL_SetRelativeMouseMode(SDL_TRUE) >= 0)
            {
                SDL_SetWindowGrab(screen, SDL_TRUE);
                relativemouse = true;
            }
            else
            {
                SDL_SetWindowGrab(screen, SDL_FALSE);
                canrelativemouse = false;
                relativemouse = false;
            }
        }
    }
    else
    {
        SDL_ShowCursor(SDL_TRUE);
        if(relativemouse)
        {
            SDL_SetRelativeMouseMode(SDL_FALSE);
            SDL_SetWindowGrab(screen, SDL_FALSE);
            relativemouse = false;
        }
    }
    shouldgrab = false;
}

std::vector<SDL_Event> events;

void pushevent(const SDL_Event &e)
{
    events.push_back(e);
}

static bool filterevent(const SDL_Event &event)
{
    switch(event.type)
    {
        case SDL_MOUSEMOTION:
            if(grabinput && !relativemouse && !(SDL_GetWindowFlags(screen) & SDL_WINDOW_FULLSCREEN))
            {
                if(event.motion.x == screenw / 2 && event.motion.y == screenh / 2)
                {
                    return false;  // ignore any motion events generated by SDL_WarpMouse
                }
            }
            break;
    }
    return true;
}

static bool pollevent(SDL_Event &event)
{
    while(SDL_PollEvent(&event))
    {
        if(filterevent(event))
        {
            return true;
        }
    }
    return false;
}

bool interceptkey(int sym)
{
    static int lastintercept = SDLK_UNKNOWN;
    int len = lastintercept == sym ? static_cast<int>(events.size()) : 0;
    SDL_Event event;
    while(pollevent(event))
    {
        switch(event.type)
        {
            case SDL_MOUSEMOTION:
            {
                break;
            }
            default:
            {
                pushevent(event);
                break;
            }
        }
    }
    lastintercept = sym;
    if(sym != SDLK_UNKNOWN)
    {
        for(size_t i = len; i < events.size(); i++)
        {
            if(events[i].type == SDL_KEYDOWN && events[i].key.keysym.sym == sym)
            {
                events.erase(events.begin() + i);
                return true;
            }
        }
    }
    return false;
}

void ignoremousemotion()
{
    SDL_Event e;
    SDL_PumpEvents();
    //go through each event and do nothing
    while(SDL_PeepEvents(&e, 1, SDL_GETEVENT, SDL_MOUSEMOTION, SDL_MOUSEMOTION))
    {
        //(empty body)
    }
}

/* resetmousemotion: resets the cursor to the middle of the screen regardless of where it is
 */
static void resetmousemotion()
{
    if(grabinput && !relativemouse && !(SDL_GetWindowFlags(screen) & SDL_WINDOW_FULLSCREEN))
    {
        SDL_WarpMouseInWindow(screen, screenw / 2, screenh / 2); //move to middle of screen
    }
}

/* checkmousemotion
 *
 * gets the information from SDL2 about the amount by which the cursor has moved, and
 * and changes the passed dx, dy values by that amount
 *
 * int &dx: pointer to the mouse x delta
 * int &dy: pointer to the mouse y delta
 */
static void checkmousemotion(int &dx, int &dy)
{
    for(size_t i = 0; i < events.size(); i++)
    {
        SDL_Event &event = events[i];
        if(event.type != SDL_MOUSEMOTION)
        {
            if(i > 0)
            {
                events.erase(events.begin(), events.begin() + i);
            }
            return;
        }
        dx += event.motion.xrel;
        dy += event.motion.yrel;
    }
    events.clear();
    SDL_Event event;
    while(pollevent(event))
    {
        if(event.type != SDL_MOUSEMOTION)
        {
            events.push_back(event);
            return;
        }
        dx += event.motion.xrel;
        dy += event.motion.yrel;
    }
}


//handle different input types
// map: which keymap to map the pressed key to
void checkinput(int map)
{
    constexpr uint minthreshhold = 5000; // minimum value to register inputs
    constexpr uint maxthreshhold = 27000; // maximum value to register inputs to triggers
    constexpr uint strafethreshhold = 16384; //value when to assign movement in strafe pad
    constexpr uint inverseindex = 16;

    constexpr uint mousemovescale = 25000; //how much to divide mouse movement by from joystick input
    //carry over joystick states
    static vec2 lpad;
    static vec2 rpad;
    static vec2 triggers; //x = left, y = right
    SDL_Event event;
    bool mousemoved = false;
    while(events.size() || pollevent(event))
    {
        if(events.size())
        {
            event = events[0];
            events.erase(events.begin());
        }
        switch(event.type)
        {
            case SDL_QUIT:
            {
                exit(EXIT_SUCCESS);
                return;
            }
            case SDL_TEXTINPUT:
            {
                if(textinputmask && static_cast<int>(event.text.timestamp-textinputtime) >= textinputfilter)
                {
                    size_t len = std::strlen(event.text.text);
                    if(len > 0)
                    {
                        processtextinput(reinterpret_cast<const char *>(event.text.text), len);
                    }
                }
                break;
            }
            case SDL_KEYDOWN:
            case SDL_KEYUP:
            {
                if(keyrepeatmask || !event.key.repeat)
                {
                    processkey(event.key.keysym.sym, event.key.state==SDL_PRESSED, map);
                }
                break;
            }
            case SDL_WINDOWEVENT:
            {
                switch(event.window.event)
                {
                    case SDL_WINDOWEVENT_CLOSE:
                    {
                        exit(EXIT_SUCCESS);
                        break;
                    }
                    case SDL_WINDOWEVENT_FOCUS_GAINED:
                    {
                        shouldgrab = true;
                        break;
                    }
                    case SDL_WINDOWEVENT_ENTER:
                    {
                        inputgrab(grabinput = true);
                        break;
                    }
                    case SDL_WINDOWEVENT_LEAVE:
                    case SDL_WINDOWEVENT_FOCUS_LOST:
                    {
                        inputgrab(grabinput = false);
                        break;
                    }
                    case SDL_WINDOWEVENT_MINIMIZED:
                    {
                        minimized = true;
                        break;
                    }
                    case SDL_WINDOWEVENT_MAXIMIZED:
                    case SDL_WINDOWEVENT_RESTORED:
                    {
                        minimized = false;
                        break;
                    }
                    case SDL_WINDOWEVENT_RESIZED:
                    {
                        break;
                    }
                    case SDL_WINDOWEVENT_SIZE_CHANGED:
                    {
                        SDL_GetWindowSize(screen, &screenw, &screenh);
                        if(!(SDL_GetWindowFlags(screen) & SDL_WINDOW_FULLSCREEN))
                        {
                            //need to cast enums to ints for std's clamp implementation
                            scr_w = std::clamp(screenw, static_cast<int>(SCR_MINW), static_cast<int>(SCR_MAXW));
                            scr_h = std::clamp(screenh, static_cast<int>(SCR_MINH), static_cast<int>(SCR_MAXH));
                        }
                        gl_resize();
                        break;
                    }
                }
                break;
            }
            case SDL_MOUSEMOTION:
            {
                if(grabinput)
                {
                    int dx = event.motion.xrel,
                        dy = event.motion.yrel;
                    checkmousemotion(dx, dy);
                    if(!UI::movecursor(dx, dy))
                    {
                        mousemove(dx, dy);
                    }
                    mousemoved = true;
                }
                else if(shouldgrab)
                {
                    inputgrab(grabinput = true);
                }
                break;
            }
            case SDL_MOUSEBUTTONDOWN:
            case SDL_MOUSEBUTTONUP:
            {
                switch(event.button.button)
                {
                    case SDL_BUTTON_LEFT:
                    {
                        processkey(Key_Left, event.button.state==SDL_PRESSED, map);
                        break;
                    }
                    case SDL_BUTTON_MIDDLE:
                    {
                        processkey(Key_Middle, event.button.state==SDL_PRESSED, map);
                        break;
                    }
                    case SDL_BUTTON_RIGHT:
                    {
                        processkey(Key_Right, event.button.state==SDL_PRESSED, map);
                        break;
                    }
                    case SDL_BUTTON_X1:
                    {
                        processkey(Key_X1, event.button.state==SDL_PRESSED, map);
                        break;
                    }
                    case SDL_BUTTON_X2:
                    {
                        processkey(Key_X2, event.button.state==SDL_PRESSED, map);
                        break;
                    }
                }
                break;
            }
            case SDL_MOUSEWHEEL:
            {
                //up
                if(event.wheel.y > 0)
                {
                    processkey(Key_ScrollUp, true, map);
                    processkey(Key_ScrollUp, false, map);
                }
                //down
                else if(event.wheel.y < 0)
                {
                    processkey(Key_ScrollDown, true, map);
                    processkey(Key_ScrollDown, false, map);
                }
                break;
            }
            case SDL_CONTROLLERBUTTONDOWN:
            case SDL_CONTROLLERBUTTONUP:
            {
                processkey(event.cbutton.button + (1<<29), event.cbutton.state == SDL_PRESSED, map); //1<<30 is used for non-char keybinds, 1<<29 is an unused part of the namespace
                break;
            }
            case SDL_CONTROLLERAXISMOTION:
            {
                uint axis = event.caxis.axis;
                uint value = event.caxis.value;
                switch(axis)
                {
                    case 0: //left x axis
                        //these processkeys will push back 1<<28 to keep out of the way of other binds
                        if(lpad.x >= strafethreshhold)
                        {
                            processkey(axis + (1<<28), true, map); //strafe in +x direction
                        }
                        else if(lpad.x <= -strafethreshhold)
                        {
                            processkey(axis + (1<<28) + inverseindex, true, map); //-x dir
                        }
                        else //no input
                        {
                            processkey(axis + (1<<28), false, map);
                            processkey(axis + (1<<28) + inverseindex, false, map);
                        }
                        lpad.x = value;
                        break;
                    case 1: //left y axis
                        //these processkeys will push back 1<<28 to keep out of the way of other binds
                        if(lpad.y >= strafethreshhold)
                        {
                            processkey(axis + (1<<28), true, map);
                        }
                        else if(lpad.y <= -strafethreshhold)
                        {
                            processkey(axis + (1<<28) + inverseindex, true, map);
                        }
                        else
                        {
                            processkey(axis + (1<<28), false, map);
                            processkey(axis + (1<<28) + inverseindex, false, map);
                        }
                        lpad.y = value;
                        break;
                    case 2: //right x axis
                        rpad.x = value;
                        break;
                    case 3: //right y axis
                        rpad.y = value;
                        break;
                    case 4: //left trigger
                        //these processkeys will push back 1<<28 to keep out of the way of other binds
                        if(triggers.x >= minthreshhold && value < minthreshhold)
                        {
                            processkey(axis + (1<<28), false, map); //left trigger has been unpressed
                        }
                        else if(triggers.x <= maxthreshhold && value > maxthreshhold)
                        {
                            processkey(axis + (1<<28), true, map); //left trigger has been pressed
                        }
                        triggers.x = value;
                        break;
                    case 5: //right trigger
                        if(triggers.y >= minthreshhold && value < minthreshhold)
                        {
                            processkey(axis + (1<<28), false, map); //right trigger has been unpressed
                        }
                        else if(triggers.y <= maxthreshhold && value > maxthreshhold)
                        {
                            processkey(axis + (1<<28), true, map); //right trigger has been pressed
                        }
                        triggers.y = value;
                }
                break;
            }
        }
    }
    { //scoping brakets
        static int oldmillis;
        int delta = lastmillis-oldmillis;
        if(std::abs(rpad.x) > minthreshhold || std::abs(rpad.y) > minthreshhold)
        {
            mousemove(delta*rpad.x/mousemovescale, delta*rpad.y/mousemovescale);
        }
        oldmillis = lastmillis;
    }
    if(mousemoved)
    {
        resetmousemotion();
    }
}
